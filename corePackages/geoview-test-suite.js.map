{"version":3,"file":"corePackages/geoview-test-suite.js","mappings":"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","sources":["webpack://geoview-core/../geoview-test-suite/src/tests/suites/suite-map-varia.ts","webpack://geoview-core/../geoview-test-suite/src/tests/core/abstract-test-suite.ts","webpack://geoview-core/../geoview-test-suite/src/tests/suites/abstract-gv-test-suite.ts","webpack://geoview-core/../geoview-test-suite/src/tests/core/abstract-tester.ts","webpack://geoview-core/../geoview-test-suite/src/tests/core/exceptions.ts","webpack://geoview-core/../geoview-test-suite/src/tests/testers/config-tester.ts","webpack://geoview-core/../geoview-test-suite/src/tests/suites/suite-config.ts","webpack://geoview-core/../geoview-test-suite/src/tests/testers/layer-tester.ts","webpack://geoview-core/../geoview-test-suite/src/tests/testers/abstract-gv-tester.ts","webpack://geoview-core/../geoview-test-suite/src/tests/core/test.ts","webpack://geoview-core/../geoview-test-suite/src/tests/core/test-step.ts","webpack://geoview-core/../geoview-test-suite/src/tests/suites/suite-geochart.ts","webpack://geoview-core/../geoview-test-suite/src/tests/testers/geochart-tester.ts","webpack://geoview-core/../geoview-test-suite/src/index.tsx","webpack://geoview-core/../geoview-test-suite/src/tests/testers/map-tester.ts","webpack://geoview-core/../geoview-test-suite/src/tests/suites/suite-layer.ts"],"sourcesContent":["import type { API } from 'geoview-core/api/api';\nimport type { MapViewer } from 'geoview-core/geo/map/map-viewer';\nimport { MapTester } from '../testers/map-tester';\nimport { GVAbstractTestSuite } from './abstract-gv-test-suite';\n\n/**\n * The GeoView Test Suite.\n */\nexport class GVTestSuiteMapVaria extends GVAbstractTestSuite {\n  /** The Map Tester used in this Test Suite */\n  #mapTester: MapTester;\n\n  /**\n   * Constructs the Test Suite\n   * @param {API} api - The shared api\n   * @param {MapViewer} mapViewer - The map viewer\n   */\n  constructor(api: API, mapViewer: MapViewer) {\n    super(api, mapViewer);\n\n    // Create the Map tester\n    this.#mapTester = new MapTester(api, mapViewer);\n    this.addTester(this.#mapTester);\n  }\n\n  /**\n   * Returns the name of the Test Suite.\n   * @returns {string} The name of the Test Suite.\n   */\n  override getName(): string {\n    return 'Map Varia Test Suite';\n  }\n\n  /**\n   * Returns the description of the Test Suite.\n   * @returns {string} The description of the Test Suite.\n   */\n  override getDescriptionAsHtml(): string {\n    return 'Test Suite to perform various map related tests.';\n  }\n\n  /**\n   * Overrides the implementation to perform the tests for this Test Suite.\n   * @returns {Promise<unknown>} A Promise which resolves when tests are completed.\n   */\n  protected override onLaunchTestSuite(): Promise<unknown> {\n    // Test the map state\n    const pmapState = this.#mapTester.testMapState();\n\n    // Test the zoom\n    const pZoom = this.#mapTester.testMapZoom(5, 500);\n\n    // Resolve when all\n    return Promise.all([pmapState, pZoom]);\n  }\n}\n","import type { EventDelegateBase } from 'geoview-core/api/events/event-helper';\nimport EventHelper from 'geoview-core/api/events/event-helper';\nimport type { AbstractTester, FailureEvent, SuccessEvent, TestEvent, TestUpdatedEvent } from './abstract-tester';\nimport { TestSuiteCannotExecuteError, TestSuiteRunningError } from './exceptions';\n\n/**\n * Abstract base class for creating suite of tests.\n */\nexport abstract class AbstractTestSuite {\n  // The Testers in the Test Suite\n  #testers: AbstractTester[] = [];\n\n  /** Keep all callback delegate references */\n  #onTestersTestStartedHandlers: TesterTestDelegate[] = [];\n\n  /** Keep all callback delegate references */\n  #onTestersTestUpdatedHandlers: TesterTestUpdatedDelegate[] = [];\n\n  /** Keep all callback delegate references */\n  #onTestersTestSuccessHandlers: TesterSuccessDelegate[] = [];\n\n  /** Keep all callback delegate references */\n  #onTestersTestFailureHandlers: TesterFailureDelegate[] = [];\n\n  /**\n   * Mustoverride function to provide a name for the Test Suite.\n   */\n  abstract getName(): string;\n\n  /**\n   * Mustoverride function to provide a description, in Html format, for the Test Suite.\n   */\n  abstract getDescriptionAsHtml(): string;\n\n  /**\n   * Gets the total number of tests in the Suite.\n   * @returns {number} The total number of tests.\n   */\n  getTestsTotal(): number {\n    // Return the total tests across all testers\n    return this.#testers.reduce((total, tester) => total + tester.getTestsTotal(), 0);\n  }\n\n  /**\n   * Gets the total number of currently running tests in the Suite.\n   * @returns {number} The total number of running tests.\n   */\n  getTestsRunning(): number {\n    // Return the total running tests across all testers\n    return this.#testers.reduce((total, tester) => total + tester.getTestsRunning(), 0);\n  }\n\n  /**\n   * Gets the total number of currently done tests in the Suite.\n   * @returns {number} The total number of tests done.\n   */\n  getTestsDone(): number {\n    // Return the total completed tests across all testers\n    return this.#testers.reduce((total, tester) => total + tester.getTestsDone(), 0);\n  }\n\n  /**\n   * Gets the total number of currently done successful tests in the Suite.\n   * @returns {number} The total number of tests done.\n   */\n  getTestsDoneSuccess(): number {\n    // Return the total completed tests across all testers\n    return this.#testers.reduce((total, tester) => total + tester.getTestsDoneSuccess(), 0);\n  }\n\n  /**\n   * Gets the total number of currently done failed tests in the Suite.\n   * @returns {number} The total number of tests done.\n   */\n  getTestsDoneFailed(): number {\n    // Return the total completed tests across all testers\n    return this.#testers.reduce((total, tester) => total + tester.getTestsDoneFailed(), 0);\n  }\n\n  /**\n   * Gets if all tests are done.\n   * @returns {boolean} Indicate if the tests are all done.\n   */\n  getTestsDoneAll(): boolean {\n    return this.#testers.every((tester) => tester.getTestsDoneAll());\n  }\n\n  /**\n   * Gets if all the tests are done and successfully.\n   * @returns {boolean} Indicate if the tests are all done and finished successfully.\n   */\n  getTestsDoneAllSuccess(): boolean {\n    return this.getTestsDoneAll() && this.#testers.every((tester) => tester.getTestsDoneAllSuccess());\n  }\n\n  /**\n   * Initializes a tester as part of the Test Suite.\n   * @param {AbstractTester} tester - The tester to initialize.\n   */\n  addTester(tester: AbstractTester): void {\n    // Add it\n    this.#testers.push(tester);\n\n    // Hook it\n    tester.onStarted(this.#handleTesterTestStarted.bind(this));\n    tester.onStepUpdated(this.#handleTesterTestStepUpdated.bind(this));\n    tester.onSuccess(this.#handleTesterSuccess.bind(this));\n    tester.onFailure(this.#handleTesterFailure.bind(this));\n  }\n\n  /**\n   * Launches the test suite.\n   * @returns {Promise<unknown>} Resolves when the tests are over.\n   */\n  async launchTestSuite(): Promise<unknown> {\n    // Validates the Test Suite isn't already running tests\n    if (this.getTestsRunning() > 0) throw new TestSuiteRunningError('The Test Suite is already running, please wait to prevent errors.');\n\n    // Validates the Test Suite can execute\n    if (!(await this.onCanExecuteTestSuite())) throw new TestSuiteCannotExecuteError();\n\n    // Launching test suite\n    return this.onLaunchTestSuite();\n  }\n\n  /**\n   * Resets all the testers in the suite.\n   */\n  resetTestSuite(): void {\n    // Validates the Test Suite isn't already running tests\n    if (this.getTestsRunning() > 0) throw new TestSuiteRunningError('The Test Suite is running, please wait to prevent errors.');\n\n    // Resets tests in all testers\n    this.#testers.forEach((tester) => tester.resetTests());\n  }\n\n  /**\n   * Overridable function called when the test suite has launched its tests.\n   * @returns {Promise<unknown>} Resolves when the tests are over.\n   */\n  protected abstract onLaunchTestSuite(): Promise<unknown>;\n\n  /**\n   * Overridable function called when the test suite is about to launch, to validate if it can be executed on the given map.\n   * @returns {Promise<boolean>} A Promise resolving to true if the test suite can execute on the given map.\n   */\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this\n  protected onCanExecuteTestSuite(): Promise<boolean> {\n    return Promise.resolve(true);\n  }\n\n  // #region PRIVATE\n\n  /**\n   * Handles the event indicating that a tester has started running a test,\n   * and re-emits it with additional context.\n   * This method allows external consumers to listen for when a test begins\n   * execution on a specific tester.\n   * @param {AbstractTester} sender - The tester instance that started the test.\n   * @param {TestEvent} event - The event containing the test that has started.\n   */\n  #handleTesterTestStarted(sender: AbstractTester, event: TestEvent): void {\n    // Re-emit\n    this.#emitTestStarted({ ...event, tester: sender });\n  }\n\n  /**\n   * Handles an event indicating that a test's step or state has been updated,\n   * and re-emits it with additional tester context.\n   * @param {AbstractTester} sender - The tester instance that updated the test.\n   * @param {TestUpdatedEvent} event - The event containing the updated test and its internal event.\n   */\n  #handleTesterTestStepUpdated(sender: AbstractTester, event: TestUpdatedEvent): void {\n    // Re-emit\n    this.#emitTestUpdated({ ...event, tester: sender });\n  }\n\n  /**\n   * Handles a successful test completion event from a tester,\n   * and re-emits it with additional tester context.\n   * @param {AbstractTester} sender - The tester instance that completed the test successfully.\n   * @param {SuccessEvent} event - The event containing the test and its resulting data.\n   */\n  #handleTesterSuccess(sender: AbstractTester, event: SuccessEvent): void {\n    // Re-emit\n    this.#emitSuccess({ ...event, tester: sender });\n  }\n\n  /**\n   * Handles a test failure event emitted by a tester,\n   * and re-emits it with additional tester context.\n   * @param {AbstractTester} sender - The tester instance that encountered the failure.\n   * @param {FailureEvent} event - The event containing the test and the associated error.\n   */\n  #handleTesterFailure(sender: AbstractTester, event: FailureEvent): void {\n    // Re-emit\n    this.#emitFailure({ ...event, tester: sender });\n  }\n\n  // #endregion PRIVATE\n\n  // #region EVENTS\n\n  /**\n   * Emits an event to all handlers.\n   * @param {TesterTestEvent} event - The event to emit\n   * @private\n   */\n  #emitTestStarted(event: TesterTestEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onTestersTestStartedHandlers, event);\n  }\n\n  /**\n   * Registers a test started event handler.\n   * @param {TesterTestDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onTestStarted(callback: TesterTestDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onTestersTestStartedHandlers, callback);\n  }\n\n  /**\n   * Unregisters a test started event handler.\n   * @param {TesterTestDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offTestStarted(callback: TesterTestDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onTestersTestStartedHandlers, callback);\n  }\n\n  /**\n   * Emits an event to all handlers.\n   * @param {TesterTestUpdatedEvent} event - The event to emit\n   * @private\n   */\n  #emitTestUpdated(event: TesterTestUpdatedEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onTestersTestUpdatedHandlers, event);\n  }\n\n  /**\n   * Registers a test updated event handler.\n   * @param {TesterTestUpdatedDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onTestUpdated(callback: TesterTestUpdatedDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onTestersTestUpdatedHandlers, callback);\n  }\n\n  /**\n   * Unregisters a test updateduccess event handler.\n   * @param {TesterTestUpdatedDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offTestUpdated(callback: TesterTestUpdatedDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onTestersTestUpdatedHandlers, callback);\n  }\n\n  /**\n   * Emits an event to all handlers.\n   * @param {TesterSuccessEvent} event - The event to emit\n   * @private\n   */\n  #emitSuccess(event: TesterSuccessEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onTestersTestSuccessHandlers, event);\n  }\n\n  /**\n   * Registers a success event handler.\n   * @param {TesterSuccessDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onSuccess(callback: TesterSuccessDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onTestersTestSuccessHandlers, callback);\n  }\n\n  /**\n   * Unregisters a success event handler.\n   * @param {TesterSuccessDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offSuccess(callback: TesterSuccessDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onTestersTestSuccessHandlers, callback);\n  }\n\n  /**\n   * Emits an event to all handlers.\n   * @param {TesterFailureEvent} event - The event to emit\n   * @private\n   */\n  #emitFailure(event: TesterFailureEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onTestersTestFailureHandlers, event);\n  }\n\n  /**\n   * Registers a failure event handler.\n   * @param {TesterFailureDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onFailure(callback: TesterFailureDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onTestersTestFailureHandlers, callback);\n  }\n\n  /**\n   * Unregisters a failure event handler.\n   * @param {TesterFailureDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offFailure(callback: TesterFailureDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onTestersTestFailureHandlers, callback);\n  }\n\n  // #endregion EVENTS\n}\n\n/**\n * Define an event for the delegate\n */\nexport interface TesterTestEvent extends TestEvent {\n  tester: AbstractTester;\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type TesterTestDelegate = EventDelegateBase<AbstractTestSuite, TesterTestEvent, void>;\n\n/**\n * Define an event for the delegate\n */\nexport interface TesterTestUpdatedEvent extends TestUpdatedEvent {\n  tester: AbstractTester;\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type TesterTestUpdatedDelegate = EventDelegateBase<AbstractTestSuite, TesterTestUpdatedEvent, void>;\n\n/**\n * Define an event for the delegate\n */\nexport interface TesterSuccessEvent extends SuccessEvent {\n  tester: AbstractTester;\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type TesterSuccessDelegate = EventDelegateBase<AbstractTestSuite, TesterSuccessEvent, void>;\n\n/**\n * Define an event for the delegate\n */\nexport interface TesterFailureEvent extends FailureEvent {\n  tester: AbstractTester;\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type TesterFailureDelegate = EventDelegateBase<AbstractTestSuite, TesterFailureEvent, void>;\n","import type { API } from 'geoview-core/api/api';\nimport type { MapViewer } from 'geoview-core/geo/map/map-viewer';\nimport { AbstractTestSuite } from '../core/abstract-test-suite';\n\n/**\n * Main GeoView Abstract Suite class.\n */\nexport abstract class GVAbstractTestSuite extends AbstractTestSuite {\n  /** The api */\n  #api: API;\n\n  /** The MapViewer */\n  #mapViewer: MapViewer;\n\n  /**\n   * Constructs an {@link GVAbstractTestSuite} instance.\n   * @param {API} api - The api, mainly used to retrieve the MapViewer.\n   * @param {string} mapViewer - The map viewer.\n   */\n  protected constructor(api: API, mapViewer: MapViewer) {\n    super();\n\n    // Keep attributes\n    this.#api = api;\n    this.#mapViewer = mapViewer;\n  }\n\n  /**\n   * Gets the shared api.\n   */\n  getApi(): API {\n    return this.#api;\n  }\n\n  /**\n   * Gets the MapViewer.\n   */\n  getMapViewer(): MapViewer {\n    return this.#mapViewer;\n  }\n\n  /**\n   * Gets the Map Id.\n   */\n  getMapId(): string {\n    return this.#mapViewer.mapId;\n  }\n}\n","import type { BaseTestChangedEvent, ClassType } from './test';\nimport type { EventDelegateBase } from 'geoview-core/api/events/event-helper';\nimport EventHelper from 'geoview-core/api/events/event-helper';\nimport { logger } from 'geoview-core/core/utils/logger';\nimport { Test } from './test';\nimport { formatError } from 'geoview-core/core/exceptions/core-exceptions';\n\n/**\n * Abstract base class for creating custom testers with assertion and event capabilities.\n * Provides utility methods for running tests (sync or async), performing assertions,\n * and emitting test result events (success, failure, testing).\n * Extend this class to implement domain-specific test behaviors.\n */\nexport abstract class AbstractTester {\n  /** Keep all callback delegate references */\n  #onTestStartedHandlers: TestDelegate[] = [];\n\n  /** Keep all callback delegate references */\n  #onTestUpdatedHandlers: TestUpdatedDelegate[] = [];\n\n  /** Keep all callback delegate references */\n  #onSuccessHandlers: SuccessDelegate[] = [];\n\n  /** Keep all callback delegate references */\n  #onFailureHandlers: FailureDelegate[] = [];\n\n  /** Keep all callback delegate references */\n  #onDoneHandlers: TestDelegate[] = [];\n\n  /** Keep all tests */\n  #tests: Test[] = [];\n\n  /** Keep the running tests */\n  #testsRunning: Test[] = [];\n\n  /** Keep the done tests */\n  #testsDone: Test[] = [];\n\n  /**\n   * Mustoverride function to provide a name for the Tester.\n   */\n  abstract getName(): string;\n\n  /**\n   * Gets the total number of tests.\n   * @returns {number} The total number of tests.\n   */\n  getTestsTotal(): number {\n    return this.#tests.length;\n  }\n\n  /**\n   * Gets the total number of currently running tests.\n   * @returns {number} The total number of tests.\n   */\n  getTestsRunning(): number {\n    return this.#testsRunning.length;\n  }\n\n  /**\n   * Gets the total number of currently done tests.\n   * @returns {number} The total number of tests.\n   */\n  getTestsDone(): number {\n    return this.#testsDone.length;\n  }\n\n  /**\n   * Gets the total number of currently done successful tests which were successful.\n   * @returns {number} The total number of tests.\n   */\n  getTestsDoneSuccess(): number {\n    return this.#testsDone.filter((test) => test.getStatus() === 'success').length;\n  }\n\n  /**\n   * Gets the total number of currently done failed tests which were successful.\n   * @returns {number} The total number of tests.\n   */\n  getTestsDoneFailed(): number {\n    return this.getTestsDone() - this.getTestsDoneSuccess();\n  }\n\n  /**\n   * Gets if all tests are done.\n   * @returns {boolean} Indicate if the tests are all done.\n   */\n  getTestsDoneAll(): boolean {\n    return this.getTestsDone() === this.getTestsTotal();\n  }\n\n  /**\n   * Gets if all the tests are done and successfully.\n   * @returns {boolean} Indicate if the tests are all done and finished successfully.\n   */\n  getTestsDoneAllSuccess(): boolean {\n    return this.getTestsDoneAll() && this.#tests.every((test) => test.getStatus() === 'success');\n  }\n\n  /**\n   * Resets all the tests\n   */\n  resetTests(): void {\n    this.#tests = [];\n    this.#testsRunning = [];\n    this.#testsDone = [];\n  }\n\n  /**\n   * Performs a test using the provided test callback and assertion callback.\n   * @template T The type of the result produced by the test.\n   * @param {string} message - A message describing the test.\n   * @param {BaseTestDelegate<T>} callback - The function to execute to obtain a test result.\n   * @param {BaseAssertionDelegate<T>} callbackAssert - The function to perform assertions on the result.\n   * @param {BaseFinalizeDelegate<T>?} [callbackFinalize] - Optional function to finalize the test after completion.\n   * @returns {Promise<TestResult<T>>} The result wrapped in an {@link TestResult} object.\n   */\n  test<T>(\n    message: string,\n    callback: BaseTestDelegate<T, T>,\n    callbackAssert: BaseAssertionDelegate<T>,\n    callbackFinalize?: BaseFinalizeDelegate<T>\n  ): Promise<Test<T>> {\n    // Redirect\n    return this.#testPerformTest(message, callback, callbackAssert, callbackFinalize);\n  }\n\n  /**\n   * Performs a test which is supposed to throw an error (a true negative) using the provided test callback and assertion callback.\n   * @template T The expected error that the test should throw.\n   * @param {string} message - A message describing the test.\n   * @param {BaseTestDelegate<T>} callback - The function to execute which should be throwing an error.\n   * @param {BaseAssertionDelegate<T>?} [callbackAssert] - Optional function to perform assertions on the result.\n   * @param {BaseFinalizeDelegate<T>?} [callbackFinalize] - Optional function to finalize the test after completion.\n   * @returns {Promise<TestResult<T>>} The result wrapped in an {@link TestResult} object.\n   */\n  testError<T extends Error>(\n    message: string,\n    errorClass: ClassType<T>,\n    callback: BaseTestDelegate<T, void>,\n    callbackAssert?: BaseAssertionDelegate<T>,\n    callbackFinalize?: BaseFinalizeDelegate<T>\n  ): Promise<Test<T>> {\n    // Redirect\n    return this.#testPerformTestError(message, errorClass, callback, callbackAssert, callbackFinalize);\n  }\n\n  // #region PROTECTED\n\n  /**\n   * Overridable function called when a test is being created for execution.\n   * @returns {Test} test - The test about to be performed.\n   * @protected\n   */\n  protected onCreatingTest<T>(message: string): Test<T> {\n    // Create the test\n    const test = new Test<T>(message);\n\n    // Hook on step changed\n    test.onStepChanged(this.#handleTestStepChanged.bind(this));\n\n    // Return the test\n    return test;\n  }\n\n  /**\n   * Overridable function called before any test is executed.\n   * @param {Test} test - The test about to be performed.\n   * @protected\n   */\n  protected onPerformingTest(test: Test): void {\n    // Log\n    logger.logDebug(`Testing ${test.getTitle()}...`);\n\n    // Add the test to the list\n    this.#tests.push(test);\n\n    // Add the test to the running list\n    this.#addTestRunning(test);\n\n    // Update the status and step\n    test.setStatus('running');\n    test.addStep('Running test...', 'major');\n\n    // Emit\n    this.#emitStarted({ test });\n  }\n\n  /**\n   * Overridable function called before any test assertion verification is executed.\n   * @param {Test} test - The test about to be assertion verified.\n   * @protected\n   */\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this\n  protected onPerformingTestAssertions(test: Test): void {\n    // Update the status and step\n    test.setStatus('verifying');\n    test.addStep('Verifying assertions...', 'major');\n\n    // TODO: Emit something?\n    // this.#emitTesting({ test });\n  }\n\n  /**\n   * Emits a test updated event.\n   * @param {Test} test - The test which updated.\n   * @param {BaseTestChangedEvent} event - The event causing the update.\n   * @protected\n   */\n  protected onPerformingTestStepChanged(test: Test, event: BaseTestChangedEvent): void {\n    // Emit\n    this.#emitStepChanged({ test, event });\n  }\n\n  /**\n   * Emits a success event.\n   * @param {Test} test - The test which succeeded.\n   * @param {T} result - The assertion result.\n   * @protected\n   */\n  protected onPerformingTestSuccess<T>(test: Test<T>, result: T): void {\n    // Update the step - clearing it\n    test.setStatus('success');\n\n    // Emit\n    this.#emitSuccess({ test, result });\n  }\n\n  /**\n   * Emits a failure event with a normalized error object.\n   * @param {Test} test - The test which failed.\n   * @param {unknown} error - The thrown error from the assertion or test logic.\n   * @param {boolean} duringFinalization - Indicates if the failure happened during finalization or during the Test regular processing.\n   * @protected\n   */\n  protected onPerformingTestFailure<T>(test: Test<T>, error: unknown, duringFinalization: boolean): void {\n    // The original status\n    const originalStatus = test.getStatus();\n\n    // Marshall the error\n    const normalizedError = error instanceof Error ? error : new Error(String(error));\n\n    // Set status to failed\n    test.setStatus('failed');\n\n    // Determine whether to override the error and emit\n    // This makes sure we don't override with the finalization error as the original error is more important.\n    const shouldSetError = !duringFinalization || originalStatus !== 'failed';\n\n    // If setting the error\n    if (shouldSetError) {\n      // Set the error\n      test.setError(normalizedError);\n      // Emit\n      this.#emitFailure({ test, error: normalizedError });\n    }\n  }\n\n  /**\n   * Emits a finalize event.\n   * @param {Test} test - The test which is finalizing.\n   * @protected\n   */\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this\n  protected onPerformingTestFinalization<T>(test: Test<T>, callback?: BaseFinalizeDelegate<T>): void {\n    // If we do have a callback for finalization\n    if (callback) {\n      // Add done step\n      test.addStep('Cleaning up...', 'major');\n    }\n  }\n\n  /**\n   * Emits a done event.\n   * @param {Test} test - The test which is finalizing.\n   * @protected\n   */\n  protected onPerformingTestDone<T>(test: Test<T>): void {\n    // Move the test from the running list and add it to the done list\n    this.#moveTestFromRunningToDone(test);\n\n    // Add done step\n    test.addStep('Done', 'major', test.getStatus() === 'success' ? 'green' : 'red');\n\n    // Emit\n    this.#emitDone({ test });\n  }\n\n  // #endregion PROTECTED\n\n  // #region PRIVATE\n\n  /**\n   * Executes the full lifecycle of a test, including setup, execution, assertion, success/failure handling, and optional finalization.\n   * The lifecycle consists of:\n   * - Creating a new test instance\n   * - Executing the core test logic via a callback\n   * - Storing the result in the test\n   * - Running assertions on the result\n   * - Handling success or failure states\n   * - Optionally finalizing the test (e.g., cleanup or logging)\n   * @template T - The type of the result returned by the test.\n   * @param {string} message - A human-readable description of the test.\n   * @param {BaseTestDelegate<T>} callback - Function that performs the main test logic and returns the result.\n   * @param {BaseAssertionDelegate<T>} callbackAssert - Function that asserts the correctness of the test result.\n   * @param {BaseFinalizeDelegate<T>} [callbackFinalize] - Optional finalization callback, called after the test completes (regardless of success or failure).\n   * @returns {Promise<Test<T>>} A promise that resolves to the fully populated {@link Test} object.\n   * @private\n   */\n  async #testPerformTest<T>(\n    message: string,\n    callback: BaseTestDelegate<T, T>,\n    callbackAssert: BaseAssertionDelegate<T>,\n    callbackFinalize?: BaseFinalizeDelegate<T>\n  ): Promise<Test<T>> {\n    // Create the test\n    const test = this.onCreatingTest<T>(message);\n\n    try {\n      // Testing\n      this.onPerformingTest(test);\n\n      // Start the test and await\n      const result = await callback(test);\n\n      // Assign it to the current test\n      test.setResult(result);\n\n      // Checking assertions\n      this.onPerformingTestAssertions(test);\n\n      // Callback with the result to verify using an assertion check\n      await callbackAssert(test, result);\n\n      // All good\n      this.onPerformingTestSuccess(test, result);\n    } catch (error: unknown) {\n      // The execution of the test has failed\n      this.onPerformingTestFailure(test, error, false);\n    }\n\n    try {\n      // Finalizing\n      this.onPerformingTestFinalization(test, callbackFinalize);\n\n      // Possibly callback for more\n      await callbackFinalize?.(test);\n    } catch (error: unknown) {\n      // The execution of the test has failed during finalization\n      this.onPerformingTestFailure(test, error, true);\n    }\n\n    // Done\n    this.onPerformingTestDone(test);\n\n    // Return the test\n    return test;\n  }\n\n  /**\n   * Executes the full lifecycle of a test when testing for an Error to be thrown, including setup, execution, assertion, success/failure handling, and optional finalization.\n   * The lifecycle consists of:\n   * - Creating a new test instance\n   * - Executing the core test logic via a callback, expecting an error to be thrown\n   * - Storing the result in the test\n   * - Optionally running additional assertions on the result\n   * - Handling success or failure states\n   * - Optionally finalizing the test (e.g., cleanup or logging)\n   * @template T - The type of the result returned by the test.\n   * @param {string} message - A human-readable description of the test.\n   * @param {BaseTestDelegate<T>} callback - Function that performs the main test logic and is supposed to throw an Error.\n   * @param {BaseAssertionDelegate<T>} callbackAssert - Function that asserts the correctness of the test result.\n   * @param {BaseFinalizeDelegate<T>} [callbackFinalize] - Optional finalization callback, called after the test completes (regardless of success or failure).\n   * @returns {Promise<Test<T>>} A promise that resolves to the fully populated {@link Test} object.\n   * @private\n   */\n  async #testPerformTestError<T extends Error>(\n    message: string,\n    errorClass: ClassType<T>,\n    callback: BaseTestDelegate<T, void>,\n    callbackAssert?: BaseAssertionDelegate<T>,\n    callbackFinalize?: BaseFinalizeDelegate<T>\n  ): Promise<Test<T>> {\n    // Create the test\n    const test = this.onCreatingTest<T>(message);\n\n    // Set the type to a true-negative, because we're testing for an Error.\n    test.setType('true-negative');\n\n    try {\n      // Testing\n      this.onPerformingTest(test);\n\n      // Start the test and expect it to fail\n      let result: Error | undefined = undefined;\n      try {\n        await callback(test);\n      } catch (error: unknown) {\n        // An error happened, as expected\n        result = formatError(error);\n\n        // Check if the right type\n        // Assign it to the current test\n        test.setResult(result as T);\n      }\n\n      // Checking assertions\n      this.onPerformingTestAssertions(test);\n\n      // Creating the configuration\n      test.addStep('Verifying the Error obtained is of the correct class type...');\n\n      // Check if the result is instance of the error we're testing for\n      Test.assertIsErrorInstance(result as T, errorClass);\n\n      // Callback with the result to verify using an assertion check\n      await callbackAssert?.(test, result as T);\n\n      // All good\n      this.onPerformingTestSuccess(test, result);\n    } catch (error: unknown) {\n      // The execution of the test has failed\n      this.onPerformingTestFailure(test, error, false);\n    }\n\n    try {\n      // Finalizing\n      this.onPerformingTestFinalization(test, callbackFinalize);\n\n      // Possibly callback for more\n      await callbackFinalize?.(test);\n    } catch (error: unknown) {\n      // The execution of the test has failed during finalization\n      this.onPerformingTestFailure(test, error, true);\n    }\n\n    // Done\n    this.onPerformingTestDone(test);\n\n    // Return the test\n    return test;\n  }\n\n  /**\n   * Adds a test to the list of currently running tests.\n   * @param {Test} test - The test instance to add to the running list.\n   */\n  #addTestRunning(test: Test): void {\n    this.#testsRunning.push(test);\n  }\n\n  /**\n   * Moves a test from the list of running tests to the list of completed tests.\n   * This method removes the specified test from the `#testsRunning` list (if found by ID)\n   * and appends it to the `#testsDone` list.\n   * @param {Test} test - The test instance to move.\n   */\n  #moveTestFromRunningToDone(test: Test): void {\n    // Find it\n    const index = this.#testsRunning.findIndex((t) => t.id === test.id);\n    if (index !== -1) {\n      this.#testsRunning.splice(index, 1);\n    }\n\n    // Add to done\n    this.#testsDone.push(test);\n  }\n\n  /**\n   * Handles updates to a test by invoking the relevant change handler.\n   * @param {Test} sender - The test instance that triggered the change.\n   * @param {BaseTestChangedEvent} event - The event details describing the change.\n   */\n  #handleTestStepChanged(sender: Test, event: BaseTestChangedEvent): void {\n    // Performing test has been updated\n    this.onPerformingTestStepChanged(sender, event);\n  }\n\n  // #endregion\n\n  // #region EVENTS\n\n  /**\n   * Emits an event to all handlers.\n   * @param {TestEvent} event - The event to emit\n   * @private\n   */\n  #emitStarted(event: TestEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onTestStartedHandlers, event);\n  }\n\n  /**\n   * Registers a test started event handler.\n   * @param {TestDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onStarted(callback: TestDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onTestStartedHandlers, callback);\n  }\n\n  /**\n   * Unregisters a test started event handler.\n   * @param {TestDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offStarted(callback: TestDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onTestStartedHandlers, callback);\n  }\n\n  /**\n   * Emits an event to all handlers.\n   * @param {TestUpdatedEvent} event - The event to emit\n   * @private\n   */\n  #emitStepChanged(event: TestUpdatedEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onTestUpdatedHandlers, event);\n  }\n\n  /**\n   * Registers a step updated event handler.\n   * @param {TestUpdatedDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onStepUpdated(callback: TestUpdatedDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onTestUpdatedHandlers, callback);\n  }\n\n  /**\n   * Unregisters a step updated event handler.\n   * @param {TestUpdatedDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offStepUpdated(callback: TestUpdatedDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onTestUpdatedHandlers, callback);\n  }\n\n  /**\n   * Emits an event to all handlers.\n   * @param {SuccessEvent} event - The event to emit\n   * @private\n   */\n  #emitSuccess(event: SuccessEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onSuccessHandlers, event);\n  }\n\n  /**\n   * Registers a success event handler.\n   * @param {SuccessDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onSuccess(callback: SuccessDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onSuccessHandlers, callback);\n  }\n\n  /**\n   * Unregisters a success event handler.\n   * @param {SuccessDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offSuccess(callback: SuccessDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onSuccessHandlers, callback);\n  }\n\n  /**\n   * Emits an event to all handlers.\n   * @param {FailureEvent} event - The event to emit\n   * @private\n   */\n  #emitFailure(event: FailureEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onFailureHandlers, event);\n  }\n\n  /**\n   * Registers a failure event handler.\n   * @param {FailureDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onFailure(callback: FailureDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onFailureHandlers, callback);\n  }\n\n  /**\n   * Unregisters a failure event handler.\n   * @param {FailureDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offFailure(callback: FailureDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onFailureHandlers, callback);\n  }\n\n  /**\n   * Emits an event to all handlers.\n   * @param {TestEvent} event - The event to emit\n   * @private\n   */\n  #emitDone(event: TestEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onDoneHandlers, event);\n  }\n\n  /**\n   * Registers a done event handler.\n   * @param {TestDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onDone(callback: TestDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onDoneHandlers, callback);\n  }\n\n  /**\n   * Unregisters a done event handler.\n   * @param {TestDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offDone(callback: TestDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onDoneHandlers, callback);\n  }\n\n  // #endregion EVENTS\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type BaseTestDelegate<T = unknown, U = unknown> = (test: Test<T>) => U | Promise<U>;\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type BaseAssertionDelegate<T = unknown> = (test: Test<T>, result: T) => void | Promise<void>;\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type BaseFinalizeDelegate<T = unknown> = (test: Test<T>) => void | Promise<void>;\n\n/**\n * Define an event for the delegate\n */\nexport interface TestEvent {\n  test: Test;\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type TestDelegate = EventDelegateBase<AbstractTester, TestEvent, void>;\n\n/**\n * Define an event for the delegate\n */\nexport interface TestUpdatedEvent<T = BaseTestChangedEvent> {\n  test: Test;\n  event: T;\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type TestUpdatedDelegate = EventDelegateBase<AbstractTester, TestUpdatedEvent, void>;\n\n/**\n * Define an event for the delegate\n */\nexport interface SuccessEvent<T = unknown> {\n  test: Test;\n  result: T;\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type SuccessDelegate = EventDelegateBase<AbstractTester, SuccessEvent, void>;\n\n/**\n * Define an event for the delegate\n */\nexport interface FailureEvent {\n  test: Test;\n  error: unknown;\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type FailureDelegate = EventDelegateBase<AbstractTester, FailureEvent, void>;\n","/* eslint-disable max-classes-per-file */\n\nimport type { ClassType } from './test';\n\n/**\n * Custom error to indicate that an test execution (not an Assertion) has failed.\n * @extends {Error}\n */\nexport class TestError extends Error {\n  /**\n   * Creates a new TestError.\n   * @param {string} message - Error message.\n   */\n  constructor(message: string = 'Test failed') {\n    // Call the base Error constructor with the provided message\n    super(message);\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'TestError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, TestError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, TestError.prototype);\n  }\n}\n\n/**\n * Custom error to indicate that a test suite is currently running and shouldn't be interfered with.\n * @extends {Error}\n */\nexport class TestSuiteRunningError extends Error {\n  /**\n   * Creates a new TestSuiteRunningError.\n   * @param {string} message - Error message.\n   */\n  constructor(message: string = 'The Test Suite is currently running.') {\n    // Call the base Error constructor with the provided message\n    super(message);\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'TestSuiteRunningError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, TestSuiteRunningError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, TestSuiteRunningError.prototype);\n  }\n}\n\n/**\n * Custom error to indicate that a test suite cannot execute, failing its preconditions.\n * @extends {Error}\n */\nexport class TestSuiteCannotExecuteError extends Error {\n  /**\n   * Creates a new TestSuiteCannotExecuteError.\n   */\n  constructor(message = 'The Test Suite cannot be executed.') {\n    // Call the base Error constructor with the provided message\n    super(message);\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'TestSuiteCannotExecuteError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, TestSuiteCannotExecuteError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, TestSuiteCannotExecuteError.prototype);\n  }\n}\n\n/**\n * Abstract Assertion Error to indicate that an assertion check has failed.\n * @extends {Error}\n */\nexport abstract class AssertionError extends Error {\n  /**\n   * Creates a new AssertionError.\n   * @param {string} message - Error message.\n   * @param {unknown | undefined} actual - Actual value.\n   * @param {unknown | undefined} expected - Expected value.\n   */\n  protected constructor(\n    message: string = 'Assertion failed',\n    public actual?: unknown,\n    public expected?: unknown\n  ) {\n    // Call the base Error constructor with the provided message\n    super(message);\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'AssertionError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, AssertionError.prototype);\n  }\n}\n\n/**\n * Custom error to indicate that a value wasn't as expected.\n * @extends {AssertionError}\n */\nexport class AssertionValueError extends AssertionError {\n  /**\n   * Creates a new AssertionValueError.\n   * @param {unknown} actual - Actual value.\n   * @param {unknown} expected - Expected value.\n   */\n  constructor(actual: unknown, expected: unknown) {\n    // Call the base Error constructor with the provided message\n    super(`Value is '${actual}', expected was '${expected}'.`, actual, expected);\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'AssertionValueError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionValueError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, AssertionValueError.prototype);\n  }\n}\n\n/**\n * Custom error to indicate that a value was unexpectedly undefined.\n * @extends {AssertionError}\n */\nexport class AssertionUndefinedError extends AssertionError {\n  /**\n   * Creates a new AssertionUndefinedError.\n   * @param {string} propertyPath - The name or path of the property that was undefined.\n   */\n  constructor(propertyPath: string) {\n    // Call the base Error constructor with the provided message\n    super(`Value for '${propertyPath}' was undefined.`, undefined, undefined);\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'AssertionUndefinedError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionUndefinedError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, AssertionUndefinedError.prototype);\n  }\n}\n\n/**\n * Custom error to indicate that a value was unexpectedly defined.\n * @extends {AssertionError}\n */\nexport class AssertionDefinedError extends AssertionError {\n  /**\n   * Creates a new AssertionDefinedError.\n   * @param {string} propertyPath - The name or path of the property that was undefined.\n   */\n  constructor(propertyPath: string, actualValue: unknown) {\n    // Call the base Error constructor with the provided message\n    super(`Value for '${propertyPath}' was defined.`, actualValue, undefined);\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'AssertionDefinedError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionDefinedError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, AssertionDefinedError.prototype);\n  }\n}\n\n/**\n * Custom error to indicate that a value was of wrong instance.\n * @extends {AssertionError}\n */\nexport class AssertionWrongInstanceError extends AssertionError {\n  /**\n   * Creates a new AssertionWrongInstanceError.\n   * @param {any} actualObject - The actual object.\n   * @param {Type} expectedClassType - The expected class.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(actualObject: any, expectedClassType: ClassType) {\n    // Call the base Error constructor with the provided message\n    super(\n      `Value class instance is '${actualObject.constructor.name}', expected was '${expectedClassType.name}'.`,\n      actualObject,\n      expectedClassType\n    );\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'AssertionWrongInstanceError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionWrongInstanceError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, AssertionWrongInstanceError.prototype);\n  }\n}\n\n/**\n * Custom error to indicate that no Error was thrown when one was expected (true negative tests).\n * @extends {AssertionError}\n */\nexport class AssertionNoErrorThrownError extends AssertionError {\n  /**\n   * Creates a new AssertionNoErrorThrownError.\n   * @param {Type} expectedClassType - The expected class.\n   */\n  constructor(expectedClassType: ClassType) {\n    // Call the base Error constructor with the provided message\n    super(`No error was thrown when an error '${expectedClassType.name}' was expected.`, undefined, expectedClassType);\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'AssertionNoErrorThrownError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionNoErrorThrownError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, AssertionNoErrorThrownError.prototype);\n  }\n}\n\n/**\n * Custom error to indicate that an error was of wrong instance.\n * @extends {AssertionError}\n */\nexport class AssertionWrongErrorInstanceError extends AssertionError {\n  /**\n   * Creates a new AssertionWrongErrorInstanceError.\n   * @param {Error} actualError - The actual error object.\n   * @param {Type} expectedClassType - The expected class.\n   */\n  constructor(actualError: Error, expectedClassType: ClassType) {\n    // Call the base Error constructor with the provided message\n    super(\n      `Error '${actualError.message}' instance is '${actualError.constructor.name}', expected was '${expectedClassType.name}'.`,\n      actualError,\n      expectedClassType\n    );\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'AssertionWrongErrorInstanceError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionWrongErrorInstanceError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, AssertionWrongErrorInstanceError.prototype);\n  }\n}\n\n/**\n * Custom error to indicate that an array did not have the expected length.\n * @extends {AssertionError}\n */\nexport class AssertionArrayLengthError extends AssertionError {\n  /**\n   * Creates a new AssertionArrayLengthError.\n   * @param {number | undefined} actualLength - Actual array length.\n   * @param {number} expectedLength - Expected array length.\n   */\n  constructor(actualLength: number | undefined, expectedLength: number) {\n    // Call the base Error constructor with the provided message\n    super(`Array length is ${actualLength}, expected was ${expectedLength}`, actualLength, expectedLength);\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'AssertionArrayLengthError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionArrayLengthError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, AssertionArrayLengthError.prototype);\n  }\n}\n\n/**\n * Custom error to indicate that an array did not have the minimum expected length.\n * @extends {AssertionError}\n */\nexport class AssertionArrayLengthMinimalError extends AssertionError {\n  /**\n   * Creates a new AssertionArrayLengthMinimalError.\n   * @param {number | undefined} actualLength - Actual array length.\n   * @param {number} expectedLength - Expected array length.\n   */\n  constructor(actualLength: number | undefined, expectedLength: number) {\n    // Call the base Error constructor with the provided message\n    super(`Array length is ${actualLength}, expected was at least ${expectedLength}`, actualLength, expectedLength);\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'AssertionArrayLengthMinimalError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionArrayLengthMinimalError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, AssertionArrayLengthMinimalError.prototype);\n  }\n}\n\n/**\n * Custom error to indicate that an array did not include the expected value (so the inclusion failed).\n * @extends {AssertionError}\n */\nexport class AssertionArrayIncludingError<T> extends AssertionError {\n  /**\n   * Creates a new AssertionArrayIncludingError.\n   * @param {T[] | undefined} array - Actual array.\n   * @param {T} expectedValue - Expected value in the array.\n   */\n  constructor(array: T[] | undefined, expectedValue: T) {\n    // Call the base Error constructor with the provided message\n    super(`Array does not include ${expectedValue}`, array, expectedValue);\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'AssertionArrayIncludingError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionArrayIncludingError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, AssertionArrayIncludingError.prototype);\n  }\n}\n\n/**\n * Custom error to indicate that an array did included a particular value (so the exclusion failed).\n * @extends {AssertionError}\n */\nexport class AssertionArrayExcludingError<T> extends AssertionError {\n  /**\n   * Creates a new AssertionArrayExcludingError.\n   * @param {T[] | undefined} array - Actual array.\n   * @param {T} expectedValue - Expected value in the array.\n   */\n  constructor(array: T[] | undefined, expectedValue: T) {\n    // Call the base Error constructor with the provided message\n    super(`Array includes ${expectedValue}`, array, expectedValue);\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'AssertionArrayExcludingError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionArrayExcludingError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, AssertionArrayExcludingError.prototype);\n  }\n}\n\n/**\n * Custom error to indicate that an assertion check has failed.\n * @extends {AssertionError}\n */\nexport class AssertionJSONObjectError extends AssertionError {\n  /**\n   * Creates a new AssertionJSONObjectError.\n   * @param {string[]} mismatchesPaths - The mismatches.\n   * @param {unknown} actual - Actual value.\n   * @param {unknown} expected - Expected value.\n   */\n  constructor(mismatchesPaths: string[], actual: unknown, expected: unknown) {\n    // Call the base Error constructor with the provided message\n    super('JSON objects have different property/values than expected.', actual, expected);\n\n    // Format\n    const mismatches = mismatchesPaths.map((path) => `- ${path}`).join('\\n');\n\n    // If actual and expected values\n    if (mismatchesPaths) this.message += ` Mismatches are:\\n${mismatches}.`;\n\n    // Set a custom name for the error type to differentiate it from other error types\n    this.name = 'AssertionJSONObjectError';\n\n    // Capture the stack trace (V8-specific, e.g., Chrome and Node.js)\n    // Omits the constructor call from the trace for cleaner debugging\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionJSONObjectError);\n    }\n\n    // Ensure the prototype chain is correct (required in some transpilation targets)\n    Object.setPrototypeOf(this, AssertionJSONObjectError.prototype);\n  }\n}\n","import { GVAbstractTester } from './abstract-gv-tester';\nimport type { ClassType } from '../core/test';\nimport { Test } from '../core/test';\nimport type { TypeGeoviewLayerConfig, TypeGeoviewLayerType } from 'geoview-core/api/types/layer-schema-types';\nimport { LayerNoCapabilitiesError, LayerServiceMetadataUnableToFetchError } from 'geoview-core/core/exceptions/layer-exceptions';\nimport { EsriDynamic } from 'geoview-core/geo/layer/geoview-layers/raster/esri-dynamic';\nimport { EsriFeature } from 'geoview-core/geo/layer/geoview-layers/vector/esri-feature';\nimport { EsriImage } from 'geoview-core/geo/layer/geoview-layers/raster/esri-image';\nimport { WMS } from 'geoview-core/geo/layer/geoview-layers/raster/wms';\nimport { WFS } from 'geoview-core/geo/layer/geoview-layers/vector/wfs';\nimport { GeoJSON } from 'geoview-core/geo/layer/geoview-layers/vector/geojson';\nimport { CSV } from 'geoview-core/geo/layer/geoview-layers/vector/csv';\nimport { OgcFeature } from 'geoview-core/geo/layer/geoview-layers/vector/ogc-feature';\nimport { WKB } from 'geoview-core/geo/layer/geoview-layers/vector/wkb';\nimport { KML } from 'geoview-core/geo/layer/geoview-layers/vector/kml';\nimport { EsriImageLayerEntryConfig } from 'geoview-core/api/config/validation-classes/raster-validation-classes/esri-image-layer-entry-config';\nimport { EsriFeatureLayerEntryConfig } from 'geoview-core/api/config/validation-classes/vector-validation-classes/esri-feature-layer-entry-config';\nimport { EsriDynamicLayerEntryConfig } from 'geoview-core/api/config/validation-classes/raster-validation-classes/esri-dynamic-layer-entry-config';\nimport { GroupLayerEntryConfig } from 'geoview-core/api/config/validation-classes/group-layer-entry-config';\nimport { OgcWmsLayerEntryConfig } from 'geoview-core/api/config/validation-classes/raster-validation-classes/ogc-wms-layer-entry-config';\nimport { WfsLayerEntryConfig } from 'geoview-core/api/config/validation-classes/vector-validation-classes/wfs-layer-entry-config';\nimport { GeoJSONLayerEntryConfig } from 'geoview-core/api/config/validation-classes/vector-validation-classes/geojson-layer-entry-config';\nimport { CsvLayerEntryConfig } from 'geoview-core/api/config/validation-classes/vector-validation-classes/csv-layer-entry-config';\nimport { OgcFeatureLayerEntryConfig } from 'geoview-core/api/config/validation-classes/vector-validation-classes/ogc-layer-entry-config';\nimport { WkbLayerEntryConfig } from 'geoview-core/api/config/validation-classes/vector-validation-classes/wkb-layer-entry-config';\nimport { KmlLayerEntryConfig } from 'geoview-core/api/config/validation-classes/vector-validation-classes/kml-layer-entry-config';\nimport type { GeoCoreLayerConfigResponse } from 'geoview-core/api/config/geocore';\nimport { GeoCore } from 'geoview-core/api/config/geocore';\n\n/**\n * Main Config testing class.\n * @extends {GVAbstractTester}\n */\nexport class ConfigTester extends GVAbstractTester {\n  /**\n   * Returns the name of the Tester.\n   * @returns {string} The name of the Tester.\n   */\n  override getName(): string {\n    return 'ConfigTester';\n  }\n\n  // #region ESRI DYNAMIC\n\n  /**\n   * Tests an Esri Dynamic layer configuration using Historical Flood information.\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A Promise that resolves with a Test containing the configuration.\n   */\n  testEsriDynamicWithHistoricalFloodEvents(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url: string = ConfigTester.HISTORICAL_FLOOD_URL_MAP_SERVER;\n\n    // Test the Esri Dynamic config\n    return this.testEsriDynamic(\n      'Test an Esri Dynamic with Historical Flood Events',\n      url,\n      {\n        metadataAccessPath: url,\n        listOfLayerEntryConfig: [{ layerEntryProps: { layerName: ConfigTester.HISTORICAL_FLOOD_LAYER_NAME } }],\n      },\n      EsriDynamicLayerEntryConfig\n    );\n  }\n\n  /**\n   * Tests an Esri Dynamic layer configuration using CESI information.\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A Promise that resolves with a Test containing the configuration.\n   */\n  testEsriDynamicWithCESI(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url: string = ConfigTester.CESI_MAP_SERVER;\n\n    // Test the Esri Dynamic config\n    return this.testEsriDynamic(\n      'Test an Esri Dynamic with CESI',\n      url,\n      {\n        metadataAccessPath: url,\n        listOfLayerEntryConfig: [{ layerEntryProps: { layerName: ConfigTester.CESI_GROUP_0_LAYER_NAME } }],\n      },\n      GroupLayerEntryConfig\n    );\n  }\n\n  /**\n   * Tests an Esri Dynamic Config.\n   * @param {string} testName - The test name\n   * @param {string} url - The url of the Esri Dynamic layer\n   * @param {Record<string, unknown>} expectedConfig - The expected configuration on which the assertions will be done\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A Promise that resolves with a Test containing the configuration.\n   */\n  testEsriDynamic(\n    testName: string,\n    url: string,\n    expectedConfig: Record<string, unknown>,\n    expectedTypeFirstLayerEntry: ClassType\n  ): Promise<Test<TypeGeoviewLayerConfig>> {\n    // Dummy names\n    const gvLayerId: string = 'gvLayerId';\n    const gvLayerName: string = 'gvLayerName';\n    const gvLayerType: TypeGeoviewLayerType = 'esriDynamic';\n\n    // Complete the expected config by adding the geoviewLayerId and geoviewLayerName\n    const expectedConfigFull = {\n      ...expectedConfig,\n      geoviewLayerId: gvLayerId,\n      geoviewLayerName: gvLayerName,\n      geoviewLayerType: gvLayerType,\n    };\n\n    // Test\n    return this.test(\n      testName,\n      (test) => {\n        // Set step\n        test.addStep('Initializing config on url: ' + url);\n\n        // Initialize the layer config\n        return EsriDynamic.initGeoviewLayerConfig(gvLayerId, gvLayerName, url);\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected config...');\n        Test.assertJsonObject(result, expectedConfigFull);\n\n        // Take the first layer entry\n        test.addStep('Verifying 1st layer entry config...');\n        const layerEntry = result.listOfLayerEntryConfig[0];\n        Test.assertIsInstance(layerEntry, expectedTypeFirstLayerEntry);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of an Esri Dynamic layer configuration when initialized with a bad URL.\n   * This is a negative test case where the `EsriDynamic.initGeoviewLayerConfig` method is expected\n   * to fail due to an unreachable or invalid service URL. The test verifies that a\n   * `LayerServiceMetadataUnableToFetchError` is thrown as expected.\n   * @returns {Promise<Test<LayerServiceMetadataUnableToFetchError>>}\n   * A test object representing the result of the failed layer initialization attempt.\n   */\n  testEsriDynamicBadUrl(): Promise<Test<LayerServiceMetadataUnableToFetchError>> {\n    // The bad url\n    const urlBad: string = GVAbstractTester.BAD_URL;\n\n    // Test\n    return this.testError(`Test an EsriDynamic config with a bad url...`, LayerServiceMetadataUnableToFetchError, async (test) => {\n      // Creating the configuration\n      test.addStep('Creating the GeoView Layer Configuration...');\n\n      // Try it and expect a fail\n      await EsriDynamic.initGeoviewLayerConfig('gvLayerId', 'gvLayerName', urlBad);\n    });\n  }\n\n  // #endregion ESRI DYNAMIC\n\n  // #region ESRI FEATURE\n\n  /**\n   * Runs a test using an Esri Feature service for the Toronto Neighbourhoods layer.\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A promise that resolves to the configured test instance.\n   */\n  testEsriFeatureWithTorontoNeighbourhoods(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url = ConfigTester.FEATURE_SERVER_TORONTO_NEIGHBOURHOODS_URL;\n\n    // Test the Esri Feature config\n    return this.testEsriFeature('Test an Esri Feature with Toronto Neighbourhoods', url, {\n      metadataAccessPath: url,\n      listOfLayerEntryConfig: [\n        { layerEntryProps: { layerId: '0', layerName: ConfigTester.FEATURE_SERVER_TORONTO_NEIGHBOURHOODS_LAYER_NAME } },\n      ],\n    });\n  }\n\n  /**\n   * Runs a test using an Esri Feature service for the Historical Flood Events layer.\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A promise that resolves to the configured test instance.\n   */\n  testEsriFeatureWithHistoricalFloodEvents(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url = ConfigTester.HISTORICAL_FLOOD_URL_FEATURE_SERVER;\n    const expectedUrl = ConfigTester.HISTORICAL_FLOOD_URL_MAP_SERVER;\n\n    // Test the Esri Feature config\n    return this.testEsriFeature('Test an Esri Feature with Historical Flood Events', url, {\n      metadataAccessPath: expectedUrl,\n      listOfLayerEntryConfig: [{ layerEntryProps: { layerId: '0', layerName: ConfigTester.HISTORICAL_FLOOD_LAYER_NAME } }],\n    });\n  }\n\n  /**\n   * Runs a test using an Esri Feature service for the Forest Industry layer.\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A promise that resolves to the configured test instance.\n   */\n  testEsriFeatureWithForestIndustry(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url = ConfigTester.FOREST_INDUSTRY_FEATURE_SERVER;\n    const expectedUrl = ConfigTester.FOREST_INDUSTRY_MAP_SERVER;\n\n    // Test the Esri Feature config\n    return this.testEsriFeature('Test an Esri Feature with Forest Industry', url, {\n      metadataAccessPath: expectedUrl,\n      listOfLayerEntryConfig: [{ layerEntryProps: { layerId: '0', layerName: ConfigTester.FOREST_INDUSTRY_LAYER_NAME } }],\n    });\n  }\n\n  /**\n   * Tests an Esri Feature Config.\n   * @param {string} testName - The test name\n   * @param {string} url - The url of the Esri Feature layer\n   * @param {Record<string, unknown>} expectedConfig - The expected configuration on which the assertions will be done\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A Promise that resolves with a Test containing the configuration.\n   */\n  testEsriFeature(testName: string, url: string, expectedConfig: Record<string, unknown>): Promise<Test<TypeGeoviewLayerConfig>> {\n    // Dummy names\n    const gvLayerId: string = 'gvLayerId';\n    const gvLayerName: string = 'gvLayerName';\n    const gvLayerType: TypeGeoviewLayerType = 'esriFeature';\n\n    // Complete the expected config by adding the geoviewLayerId and geoviewLayerName\n    const expectedConfigFull = {\n      ...expectedConfig,\n      geoviewLayerId: gvLayerId,\n      geoviewLayerName: gvLayerName,\n      geoviewLayerType: gvLayerType,\n    };\n\n    // Test\n    return this.test(\n      testName,\n      (test) => {\n        // Set step\n        test.addStep('Initializing config on url: ' + url);\n\n        // Initialize the layer config\n        return EsriFeature.initGeoviewLayerConfig(gvLayerId, gvLayerName, url);\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected config...');\n        Test.assertJsonObject(result, expectedConfigFull);\n\n        // Take the first layer entry\n        test.addStep('Verifying 1st layer entry config...');\n        const layerEntry = result.listOfLayerEntryConfig[0];\n        Test.assertIsInstance(layerEntry, EsriFeatureLayerEntryConfig);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of an Esri Feature layer configuration when initialized with a bad URL.\n   * This is a negative test case where the `EsriFeature.initGeoviewLayerConfig` method is expected\n   * to fail due to an unreachable or invalid service URL. The test verifies that a\n   * `LayerServiceMetadataUnableToFetchError` is thrown as expected.\n   * @returns {Promise<Test<LayerServiceMetadataUnableToFetchError>>}\n   * A test object representing the result of the failed layer initialization attempt.\n   */\n  testEsriFeatureBadUrl(): Promise<Test<LayerServiceMetadataUnableToFetchError>> {\n    // The bad url\n    const urlBad: string = GVAbstractTester.BAD_URL;\n\n    // Test\n    return this.testError(`Test an EsriFeature config with a bad url...`, LayerServiceMetadataUnableToFetchError, async (test) => {\n      // Creating the configuration\n      test.addStep('Creating the GeoView Layer Configuration...');\n\n      // Try it and expect a fail\n      await EsriFeature.initGeoviewLayerConfig('gvLayerId', 'gvLayerName', urlBad);\n    });\n  }\n\n  // #endregion ESRI FEATURE\n\n  // #region ESRI IMAGE\n\n  /**\n   * Tests an Esri Image using the Elevation Image Server service.\n   * @returns\n   */\n  testEsriImageWithElevation(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url = ConfigTester.IMAGE_SERVER_ELEVATION_URL;\n\n    // Test the Esri Image config\n    return this.testEsriImage('Test Esri Image with Elevation', url, {\n      metadataAccessPath: url,\n      listOfLayerEntryConfig: [{ layerEntryProps: { layerId: ConfigTester.IMAGE_SERVER_ELEVATION_LAYER_ID } }],\n    });\n  }\n\n  /**\n   * Tests an Esri Image Config.\n   * @param {string} testName - The test name\n   * @param {string} url - The url of the Esri Image layer\n   * @param {Record<string, unknown>} expectedConfig - The expected configuration on which the assertions will be done\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A Promise that resolves with a Test containing the configuration.\n   */\n  testEsriImage(testName: string, url: string, expectedConfig: Record<string, unknown>): Promise<Test<TypeGeoviewLayerConfig>> {\n    // Dummy names\n    const gvLayerId: string = 'gvLayerId';\n    const gvLayerName: string = 'gvLayerName';\n    const gvLayerType: TypeGeoviewLayerType = 'esriImage';\n\n    // Complete the expected config by adding the geoviewLayerId and geoviewLayerName\n    const expectedConfigFull = {\n      ...expectedConfig,\n      geoviewLayerId: gvLayerId,\n      geoviewLayerName: gvLayerName,\n      geoviewLayerType: gvLayerType,\n    };\n\n    // Test\n    return this.test(\n      testName,\n      (test) => {\n        // Set step\n        test.addStep('Initializing config on url: ' + url);\n\n        // Initialize the layer config\n        return EsriImage.initGeoviewLayerConfig(gvLayerId, gvLayerName, url);\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected config...');\n        Test.assertJsonObject(result, expectedConfigFull);\n\n        // Take the first layer entry\n        test.addStep('Verifying 1st layer entry config...');\n        const layerEntry = result.listOfLayerEntryConfig[0];\n        Test.assertIsInstance(layerEntry, EsriImageLayerEntryConfig);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing an Esri Image layer configuration using an invalid metadata URL.\n   * This test verifies that when an Esri Image layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerServiceMetadataUnableToFetchError}.\n   * @returns {Promise<Test<LayerServiceMetadataUnableToFetchError>>}\n   * A promise that resolves with the test result, expecting a `LayerServiceMetadataUnableToFetchError`.\n   */\n  testEsriImageBadUrl(): Promise<Test<LayerServiceMetadataUnableToFetchError>> {\n    // The bad url\n    const urlBad: string = GVAbstractTester.BAD_URL;\n\n    // Test\n    return this.testError(`Test an EsriImage config with a bad url...`, LayerServiceMetadataUnableToFetchError, async (test) => {\n      // Creating the configuration\n      test.addStep('Creating the GeoView Layer Configuration...');\n\n      // Try it and expect a fail\n      await EsriImage.initGeoviewLayerConfig('gvLayerId', 'gvLayerName', urlBad);\n    });\n  }\n\n  // #endregion ESRI IMAGE\n\n  // #region WMS\n\n  /**\n   * Tests an WMS Config using OWS Mundialis.\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A Promise that resolves with a Test containing the configuration.\n   */\n  testWMSLayerWithOWSMundialis(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url = ConfigTester.OWS_MUNDIALIS;\n\n    // Dummy names\n    const gvLayerId: string = 'gvLayerId';\n    const gvLayerType: TypeGeoviewLayerType = 'ogcWms';\n    const gvLayerName: string = 'OpenStreetMap WMS';\n    const fullSubLayers: boolean = false;\n\n    // Expected config\n    const expectedConfig = {\n      geoviewLayerId: gvLayerId,\n      geoviewLayerType: gvLayerType,\n      geoviewLayerName: gvLayerName,\n    };\n\n    // Test the Esri Feature config\n    return this.test(\n      'Test a WMS with OWS Mundialis',\n      (test) => {\n        // Set step\n        test.addStep('Initializing config on url: ' + url);\n\n        // Initialize the layer config\n        return WMS.initGeoviewLayerConfig(gvLayerId, gvLayerName, url, fullSubLayers);\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected config...');\n        Test.assertJsonObject(result, expectedConfig);\n\n        // Supposedly 11 layer entries\n        test.addStep('Verifying 11 layer entries in the config...');\n        Test.assertIsArrayLengthEqual(result.listOfLayerEntryConfig, 11);\n\n        // Take the first layer entry\n        test.addStep('Verifying 1st layer entry config...');\n        const layerEntry = result.listOfLayerEntryConfig[0];\n        Test.assertIsInstance(layerEntry, OgcWmsLayerEntryConfig);\n        Test.assertIsEqual(layerEntry.layerId, 'OSM-WMS');\n      }\n    );\n  }\n\n  /**\n   * Tests an WMS Config using Datacube MSI.\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A Promise that resolves with a Test containing the configuration.\n   */\n  testWMSLayerWithDatacubeMSI(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url = GVAbstractTester.DATACUBE_MSI;\n\n    // Dummy names\n    const gvLayerId: string = 'gvLayerId';\n    const gvLayerType: TypeGeoviewLayerType = 'ogcWms';\n    const gvLayerName: string = 'Layers / Couches';\n    const fullSubLayers: boolean = false;\n\n    // Expected config\n    const expectedConfig = {\n      geoviewLayerId: gvLayerId,\n      geoviewLayerType: gvLayerType,\n      geoviewLayerName: gvLayerName,\n    };\n\n    // Test the WMS\n    return this.test(\n      'Test a WMS with Datacube MSI',\n      (test) => {\n        // Set step\n        test.addStep('Initializing config on url: ' + url);\n\n        // Initialize the layer config\n        return WMS.initGeoviewLayerConfig(gvLayerId, gvLayerName, url, fullSubLayers);\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected config...');\n        Test.assertJsonObject(result, expectedConfig);\n\n        // Supposedly 2 layer entries\n        test.addStep('Verifying 2 layer entries in the config...');\n        Test.assertIsArrayLengthEqual(result.listOfLayerEntryConfig, 2);\n\n        // Take the first layer entry\n        test.addStep('Verifying 1st layer entry...');\n        const layerEntryFirst = result.listOfLayerEntryConfig[0];\n        Test.assertIsInstance(layerEntryFirst, OgcWmsLayerEntryConfig);\n        Test.assertIsEqual(layerEntryFirst.layerId, GVAbstractTester.DATACUBE_MSI_LAYER_NAME_MSI);\n\n        // Take the second layer entry\n        test.addStep('Verifying 2nd layer entry...');\n        const layerEntrySecond = result.listOfLayerEntryConfig[1];\n        Test.assertIsInstance(layerEntrySecond, OgcWmsLayerEntryConfig);\n        Test.assertIsEqual(layerEntrySecond.layerId, GVAbstractTester.DATACUBE_MSI_LAYER_NAME_MSI_OR_MORE);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a WMS layer configuration using an invalid metadata URL.\n   * This test verifies that when a WMS layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerNoCapabilitiesError}.\n   * @returns {Promise<Test<LayerNoCapabilitiesError>>}\n   * A promise that resolves with the test result, expecting a `LayerNoCapabilitiesError`.\n   */\n  testWMSBadUrl(): Promise<Test<LayerNoCapabilitiesError>> {\n    // GV: In the case of a WMS, since a proxy is used when the url fails, and that proxy always returns a 200 response (with an internal error inside)\n    // GV: We can't really test the LayerServiceMetadataUnableToFetchError error exception.\n\n    // The bad url\n    const urlBad: string = GVAbstractTester.BAD_URL;\n\n    // Test\n    return this.testError(`Test a WMS config with a bad url...`, LayerNoCapabilitiesError, async (test) => {\n      // Creating the configuration\n      test.addStep('Creating the GeoView Layer Configuration...');\n\n      // Try it and expect a fail\n      await WMS.initGeoviewLayerConfig('gvLayerId', 'gvLayerName', urlBad, false);\n    });\n  }\n\n  // #endregion WMS\n\n  // #region WFS\n\n  /**\n   * Tests an WFS Config using Geomet Current Conditions layer.\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A Promise that resolves with a Test containing the configuration.\n   */\n  testWFSLayerWithGeometCurrentConditions(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url = GVAbstractTester.GEOMET_URL;\n\n    // Dummy names\n    const gvLayerId: string = 'gvLayerId';\n    const gvLayerType: TypeGeoviewLayerType = 'ogcWfs';\n    const gvLayerName: string = 'Current Conditions';\n\n    // Expected config\n    const expectedConfig = {\n      geoviewLayerId: gvLayerId,\n      geoviewLayerType: gvLayerType,\n      geoviewLayerName: gvLayerName,\n    };\n\n    // Test the WMS\n    return this.test(\n      'Test a WFS with Geomet Current Conditions',\n      (test) => {\n        // Set step\n        test.addStep('Initializing config on url: ' + url);\n\n        // Initialize the layer config\n        return WFS.initGeoviewLayerConfig(gvLayerId, gvLayerName, url);\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected config...');\n        Test.assertJsonObject(result, expectedConfig);\n\n        // Supposedly 92 layer entries\n        test.addStep('Verifying 92 layer entries in the config...');\n        Test.assertIsArrayLengthEqual(result.listOfLayerEntryConfig, 92);\n\n        // Check at least one has the correct layerId\n        test.addStep('Verifying Current Conditions in the list...');\n        const foundLayerEntry = result.listOfLayerEntryConfig.find(\n          (layerEntry) => layerEntry.layerId === GVAbstractTester.GEOMET_URL_CURRENT_COND_LAYER_ID\n        );\n        Test.assertIsDefined('listOfLayerEntryConfig with Current Conditions', foundLayerEntry);\n\n        // Check it's the right type\n        test.addStep('Verifying layer entry is of the right type...');\n        Test.assertIsInstance(foundLayerEntry, WfsLayerEntryConfig);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a WFS layer configuration using an invalid metadata URL.\n   * This test verifies that when a WFS layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerServiceMetadataUnableToFetchError}.\n   * @returns {Promise<Test<LayerServiceMetadataUnableToFetchError>>}\n   * A promise that resolves with the test result, expecting a `LayerServiceMetadataUnableToFetchError`.\n   */\n  testWFSBadUrl(): Promise<Test<LayerServiceMetadataUnableToFetchError>> {\n    // The bad url\n    const urlBad: string = GVAbstractTester.BAD_URL;\n\n    // Test\n    return this.testError(`Test a WFS config with a bad url...`, LayerServiceMetadataUnableToFetchError, async (test) => {\n      // Creating the configuration\n      test.addStep('Creating the GeoView Layer Configuration...');\n\n      // Try it and expect a fail\n      await WFS.initGeoviewLayerConfig('gvLayerId', 'gvLayerName', urlBad);\n    });\n  }\n\n  /**\n   * Tests the behavior of initializing a WFS layer configuration using a 'valid' URL, but without a GetCapabilities response.\n   * This test verifies that when a WFS layer configuration is initialized and the initialization process fails as expected and throws a\n   * {@link getcaoa}.\n   * @returns {Promise<Test<LayerNoCapabilitiesError>>}\n   * A promise that resolves with the test result, expecting a `LayerNoCapabilitiesError`.\n   */\n  testWFSOkayUrlNoCap(): Promise<Test<LayerNoCapabilitiesError>> {\n    // The bad url which still respond something (not a 404, 500, etc)\n    const urlBad: string = GVAbstractTester.FAKE_URL_ALWAYS_RETURNING_RESPONSE_INSTEAD_OF_NETWORK_ERROR;\n\n    // Test\n    return this.testError(`Test a WFS config with a okay url but no capabilities...`, LayerNoCapabilitiesError, async (test) => {\n      // Creating the configuration\n      test.addStep('Creating the GeoView Layer Configuration...');\n\n      // Try it and expect a fail\n      await WFS.initGeoviewLayerConfig('gvLayerId', 'gvLayerName', urlBad);\n    });\n  }\n\n  // #endregion WFS\n\n  // #region GeoJSON\n\n  /**\n   * Tests a GeoJson Config using datasets/geojson/metadata.meta file.\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A Promise that resolves with a Test containing the configuration.\n   */\n  testGeojsonWithMetadataMeta(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url = GVAbstractTester.GEOJSON_METADATA_META;\n\n    // Dummy names\n    const gvLayerId: string = 'gvLayerId';\n    const gvLayerType: TypeGeoviewLayerType = 'GeoJSON';\n    const gvLayerName: string = 'GeojsonLayer';\n\n    // Expected config\n    const expectedConfig = {\n      geoviewLayerId: gvLayerId,\n      geoviewLayerType: gvLayerType,\n      geoviewLayerName: gvLayerName,\n    };\n\n    // Test the WMS\n    return this.test(\n      'Test a Geojson with metadata.meta file',\n      (test) => {\n        // Set step\n        test.addStep('Initializing config on url: ' + url);\n\n        // Initialize the layer config\n        return GeoJSON.initGeoviewLayerConfig(gvLayerId, gvLayerName, url);\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected config...');\n        Test.assertJsonObject(result, expectedConfig);\n\n        // Supposedly 1 layer entry\n        test.addStep('Verifying 1 layer entry in the config...');\n        Test.assertIsArrayLengthEqual(result.listOfLayerEntryConfig, 1);\n\n        // Check at least one has the correct layerId\n        test.addStep('Verifying layer id in the list...');\n        Test.assertIsEqual(result.listOfLayerEntryConfig[0].layerId, GVAbstractTester.GEOJSON_METADATA_META_FILE);\n\n        // Check it's the right type\n        test.addStep('Verifying layer entry is of the right type...');\n        Test.assertIsInstance(result.listOfLayerEntryConfig[0], GeoJSONLayerEntryConfig);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a GeoJSON layer configuration using an invalid data URL\n   * that does not point to a valid metadata file.\n   * This test verifies that when a GeoJSON layer configuration is initialized with an invalid or\n   * unreachable URL (without a `.meta` suffix), the initialization process does not throw an error,\n   * but instead correctly **skips** metadata loading as intended.\n   * @returns {Promise<Test<void>>} A promise that resolves with nothing.\n   */\n  testGeoJSONBadUrlExpectSkip(): Promise<Test<void>> {\n    // The bad url\n    const urlBad: string = GVAbstractTester.BAD_URL;\n\n    // Test\n    return this.test(\n      `Test a GeoJSON config with a bad url expecting a skip...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Try it and expect a fail\n        await GeoJSON.initGeoviewLayerConfig('gvLayerId', 'gvLayerName', urlBad);\n      },\n      (test) => {\n        // Perform assertions\n        test.addStep(`At this point, the metadata was skipped and that's as intended...`);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a GeoJSON layer configuration using an invalid metadata URL.\n   * This test verifies that when a GeoJSON layer configuration is initialized with a metadata URL\n   * ending in `.meta` that is invalid or unreachable, the initialization process correctly **fails**\n   * and throws a {@link LayerServiceMetadataUnableToFetchError}.\n   * @returns {Promise<Test<LayerServiceMetadataUnableToFetchError>>}\n   * A promise that resolves with the test result, expecting a {@link LayerServiceMetadataUnableToFetchError}.\n   */\n  testGeoJSONBadUrlExpectError(): Promise<Test<LayerServiceMetadataUnableToFetchError>> {\n    // The bad url ending in .meta\n    const urlBad: string = 'https://badurl/oops/metadata.meta';\n\n    // Test\n    return this.testError(\n      `Test a GeoJSON config with a bad url expecting a fail...`,\n      LayerServiceMetadataUnableToFetchError,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Try it and expect a fail\n        await GeoJSON.initGeoviewLayerConfig('gvLayerId', 'gvLayerName', urlBad);\n      }\n    );\n  }\n\n  // #endregion GeoJSON\n\n  // #region CSV\n\n  /**\n   * Tests a CSV Config using csv file.\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A Promise that resolves with a Test containing the configuration.\n   */\n  testCSVWithStationList(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url = GVAbstractTester.CSV_STATION_LIST;\n\n    // Dummy names\n    const gvLayerId: string = 'gvLayerId';\n    const gvLayerType: TypeGeoviewLayerType = 'CSV';\n    const gvLayerName: string = 'CSVLayer';\n\n    // Expected config\n    const expectedConfig = {\n      geoviewLayerId: gvLayerId,\n      geoviewLayerType: gvLayerType,\n      geoviewLayerName: gvLayerName,\n    };\n\n    // Test the WMS\n    return this.test(\n      'Test a CSV with CSV file',\n      (test) => {\n        // Set step\n        test.addStep('Initializing config on url: ' + url);\n\n        // Initialize the layer config\n        return CSV.initGeoviewLayerConfig(gvLayerId, gvLayerName, url);\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected config...');\n        Test.assertJsonObject(result, expectedConfig);\n\n        // Supposedly 1 layer entry\n        test.addStep('Verifying 1 layer entry in the config...');\n        Test.assertIsArrayLengthEqual(result.listOfLayerEntryConfig, 1);\n\n        // Check at least one has the correct layerId\n        test.addStep('Verifying layer id in the list...');\n        Test.assertIsEqual(result.listOfLayerEntryConfig[0].layerId, GVAbstractTester.CSV_STATION_LIST_FILE);\n\n        // Check it's the right type\n        test.addStep('Verifying layer entry is of the right type...');\n        Test.assertIsInstance(result.listOfLayerEntryConfig[0], CsvLayerEntryConfig);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a CSV layer configuration using an invalid metadata URL.\n   * This test verifies that when a CSV layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerServiceMetadataUnableToFetchError}.\n   * @returns {Promise<Test<LayerServiceMetadataUnableToFetchError>>}\n   * A promise that resolves with the test result, expecting a `LayerServiceMetadataUnableToFetchError`.\n   */\n  testCSVBadUrlExpectSkip(): Promise<Test<void>> {\n    // The bad url\n    const urlBad: string = GVAbstractTester.BAD_URL;\n\n    // Test\n    return this.test(\n      `Test a CSV config with a bad url expecting a skip...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Try it and expect a fail\n        await CSV.initGeoviewLayerConfig('gvLayerId', 'gvLayerName', urlBad);\n      },\n      (test) => {\n        // Perform assertions\n        test.addStep(`At this point, the metadata was skipped and that's as intended...`);\n      }\n    );\n  }\n\n  // #endregion CSV\n\n  // #region OGC Feature\n\n  /**\n   * Tests an OGC Feature Config using a Pygeoapi service.\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A Promise that resolves with a Test containing the configuration.\n   */\n  testOGCFeatureWithPygeoapi(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url = GVAbstractTester.PYGEOAPI_B6RYUVAKK5;\n\n    // Dummy names\n    const gvLayerId: string = 'gvLayerId';\n    const gvLayerType: TypeGeoviewLayerType = 'ogcFeature';\n    const gvLayerName: string = 'OGCLayer';\n\n    // Expected config\n    const expectedConfig = {\n      geoviewLayerId: gvLayerId,\n      geoviewLayerType: gvLayerType,\n      geoviewLayerName: gvLayerName,\n    };\n\n    // Test the WMS\n    return this.test(\n      'Test an OGC Feature with Pygeoapi',\n      (test) => {\n        // Set step\n        test.addStep('Initializing config on url: ' + url);\n\n        // Initialize the layer config\n        return OgcFeature.initGeoviewLayerConfig(gvLayerId, gvLayerName, url);\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected config...');\n        Test.assertJsonObject(result, expectedConfig);\n\n        // Supposedly 1 layer entry\n        test.addStep('Verifying 2 layer entry in the config...');\n        Test.assertIsArrayLengthEqual(result.listOfLayerEntryConfig, 2);\n\n        // Check at least one has the correct layerId\n        test.addStep('Verifying layer id in the list...');\n        Test.assertIsEqual(result.listOfLayerEntryConfig[0].layerId, GVAbstractTester.PYGEOAPI_B6RYUVAKK5_LAKES);\n\n        // Check it's the right type\n        test.addStep('Verifying layer entry is of the right type...');\n        Test.assertIsInstance(result.listOfLayerEntryConfig[0], OgcFeatureLayerEntryConfig);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing an OGC Feature layer configuration using an invalid metadata URL.\n   * This test verifies that when an OGC Feature layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerServiceMetadataUnableToFetchError}.\n   * @returns {Promise<Test<LayerServiceMetadataUnableToFetchError>>}\n   * A promise that resolves with the test result, expecting a `LayerServiceMetadataUnableToFetchError`.\n   */\n  testOGCFeatureBadUrl(): Promise<Test<LayerServiceMetadataUnableToFetchError>> {\n    // The bad url\n    const urlBad: string = GVAbstractTester.BAD_URL;\n\n    // Test\n    return this.testError(`Test an OGC Feature config with a bad url...`, LayerServiceMetadataUnableToFetchError, async (test) => {\n      // Creating the configuration\n      test.addStep('Creating the GeoView Layer Configuration...');\n\n      // Try it and expect a fail\n      await OgcFeature.initGeoviewLayerConfig('gvLayerId', 'gvLayerName', urlBad);\n    });\n  }\n\n  // #endregion OGC Feature\n\n  // #region WKB\n\n  /**\n   * Tests a WKB using South Africa.\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A Promise that resolves with a Test containing the configuration.\n   */\n  testWKBWithSouthAfrica(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url = GVAbstractTester.WKB_SOUTH_AFRICA;\n\n    // Dummy names\n    const gvLayerId: string = 'gvLayerId';\n    const gvLayerType: TypeGeoviewLayerType = 'WKB';\n    const gvLayerName: string = 'WKBLayer';\n\n    // Expected config\n    const expectedConfig = {\n      geoviewLayerId: gvLayerId,\n      geoviewLayerType: gvLayerType,\n      geoviewLayerName: gvLayerName,\n    };\n\n    // Test the WMS\n    return this.test(\n      'Test a WKB with South Africa',\n      (test) => {\n        // Set step\n        test.addStep('Initializing config on url: ' + url);\n\n        // Initialize the layer config\n        return WKB.initGeoviewLayerConfig(gvLayerId, gvLayerName, url);\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected config...');\n        Test.assertJsonObject(result, expectedConfig);\n\n        // Supposedly 1 layer entry\n        test.addStep('Verifying 1 layer entry in the config...');\n        Test.assertIsArrayLengthEqual(result.listOfLayerEntryConfig, 1);\n\n        // Check at least one has the correct layerId\n        test.addStep('Verifying layer id in the list...');\n        Test.assertIsEqual(result.listOfLayerEntryConfig[0].layerId, GVAbstractTester.WKB_SOUTH_AFRICA);\n\n        // Check it's the right type\n        test.addStep('Verifying layer entry is of the right type...');\n        Test.assertIsInstance(result.listOfLayerEntryConfig[0], WkbLayerEntryConfig);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a WKB GeoView layer configuration using an invalid metadata URL.\n   * This test verifies that when a WKB layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerServiceMetadataUnableToFetchError}.\n   * @returns {Promise<Test<LayerServiceMetadataUnableToFetchError>>}\n   * A promise that resolves with the test result, expecting a `LayerServiceMetadataUnableToFetchError`.\n   */\n  testWKBBadUrlExpectFail(): Promise<Test<LayerServiceMetadataUnableToFetchError>> {\n    // The bad url\n    const urlBad: string = 'https://badurl/oops/metadata.meta';\n\n    // Test\n    return this.testError(`Test a WKB config with a bad url...`, LayerServiceMetadataUnableToFetchError, async (test) => {\n      // Creating the configuration\n      test.addStep('Creating the GeoView Layer Configuration...');\n\n      // Try it and expect a fail\n      await WKB.initGeoviewLayerConfig('gvLayerId', 'gvLayerName', urlBad);\n    });\n  }\n\n  // #endregion WKB\n\n  // #region KML\n\n  /**\n   * Tests a KML using Tornado.\n   * @returns {Promise<Test<TypeGeoviewLayerConfig>>} A Promise that resolves when the test completes successfully.\n   */\n  testKMLWithTornado(): Promise<Test<TypeGeoviewLayerConfig>> {\n    // The url\n    const url = GVAbstractTester.KML_TORNADO;\n\n    // Dummy names\n    const gvLayerId: string = 'gvLayerId';\n    const gvLayerType: TypeGeoviewLayerType = 'KML';\n    const gvLayerName: string = 'KMLLayer';\n\n    // Expected config\n    const expectedConfig = {\n      geoviewLayerId: gvLayerId,\n      geoviewLayerType: gvLayerType,\n      geoviewLayerName: gvLayerName,\n    };\n\n    // Test the WMS\n    return this.test(\n      'Test a KML with Tornado file',\n      (test) => {\n        // Set step\n        test.addStep('Initializing config on url: ' + url);\n\n        // Initialize the layer config\n        return KML.initGeoviewLayerConfig(gvLayerId, gvLayerName, url);\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected config...');\n        Test.assertJsonObject(result, expectedConfig);\n\n        // Supposedly 1 layer entry\n        test.addStep('Verifying 1 layer entry in the config...');\n        Test.assertIsArrayLengthEqual(result.listOfLayerEntryConfig, 1);\n\n        // Check at least one has the correct layerId\n        test.addStep('Verifying layer id in the list...');\n        Test.assertIsEqual(result.listOfLayerEntryConfig[0].layerId, GVAbstractTester.KML_TORNADO_FILE);\n\n        // Check it's the right type\n        test.addStep('Verifying layer entry is of the right type...');\n        Test.assertIsInstance(result.listOfLayerEntryConfig[0], KmlLayerEntryConfig);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a KML GeoView layer configuration using an invalid URL.\n   * This test ensures that when the provided KML URL is invalid or unreachable, the initialization\n   * process correctly skips metadata loading instead of throwing an unhandled error or proceeding incorrectly.\n   * @returns {Promise<Test<void>>} A promise that resolves when the test completes successfully.\n   */\n  testKMLBadUrlExpectSkip(): Promise<Test<void>> {\n    // The bad url\n    const urlBad: string = GVAbstractTester.BAD_URL;\n\n    // Test\n    return this.test(\n      `Test a KML config with a bad url expecting a skip...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Try it and expect a fail\n        await KML.initGeoviewLayerConfig('gvLayerId', 'gvLayerName', urlBad);\n      },\n      (test) => {\n        // Perform assertions\n        test.addStep(`At this point, the metadata was skipped and that's as intended...`);\n      }\n    );\n  }\n\n  // #endregion KML\n\n  // #region Geocore\n\n  /**\n   * Tests the Geocore service using Airborne Radioactivity information.\n   * @returns {Promise<Test<GeoCoreLayerConfigResponse>>} A Promise that resolves with the Test containing the response from Geocore.\n   */\n  testStandaloneGeocoreWithAirborne(): Promise<Test<GeoCoreLayerConfigResponse>> {\n    // The values\n    const uuid = GVAbstractTester.AIRBORNE_RADIOACTIVITY_UUID;\n    const language = 'en';\n    const expectedConfig = {\n      config: {\n        geoviewLayerId: GVAbstractTester.AIRBORNE_RADIOACTIVITY_UUID,\n        geoviewLayerType: 'esriDynamic',\n        geoviewLayerName: GVAbstractTester.AIRBORNE_RADIOACTIVITY_LAYER_GROUP_NAME,\n      },\n      geocharts: {\n        [GVAbstractTester.AIRBORNE_RADIOACTIVITY_UUID_WITH_SUFFIX]: {\n          layers: [],\n          chart: 'line',\n        },\n      },\n    };\n\n    // Perform the test\n    return this.test(\n      'Test Geocore with Airborne',\n      () => {\n        // Create a layer config from UUID using Geocore\n        return GeoCore.createLayerConfigFromUUID(uuid, language, undefined, undefined);\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected geoview geocore config...');\n        Test.assertJsonObject(result, expectedConfig);\n      }\n    );\n  }\n\n  // #endregion Geocore\n}\n","import type { API } from 'geoview-core/api/api';\nimport type { MapViewer } from 'geoview-core/geo/map/map-viewer';\nimport { GVAbstractTestSuite } from './abstract-gv-test-suite';\nimport { ConfigTester } from '../testers/config-tester';\n\n/**\n * The GeoView Test Suite.\n */\nexport class GVTestSuiteConfig extends GVAbstractTestSuite {\n  /** The Config Tester used in this Test Suite */\n  #configTester: ConfigTester;\n\n  /**\n   * Constructs the Test Suite\n   * @param {API} api - The shared api\n   * @param {MapViewer} mapViewer - The map viewer\n   */\n  constructor(api: API, mapViewer: MapViewer) {\n    super(api, mapViewer);\n\n    // Create the Config tester\n    this.#configTester = new ConfigTester(api, mapViewer);\n    this.addTester(this.#configTester);\n  }\n\n  /**\n   * Returns the name of the Test Suite.\n   * @returns {string} The name of the Test Suite.\n   */\n  override getName(): string {\n    return 'Config Test Suite';\n  }\n\n  /**\n   * Returns the description of the Test Suite.\n   * @returns {string} The description of the Test Suite.\n   */\n  override getDescriptionAsHtml(): string {\n    return 'Test Suite to perform various layer config related tests.';\n  }\n\n  /**\n   * Overrides the implementation to perform the tests for this Test Suite.\n   * @returns {Promise<unknown>} A Promise which resolves when tests are completed.\n   */\n  protected override onLaunchTestSuite(): Promise<unknown> {\n    // // GV START DEBUG SECTION TO NOT HAVE TO TEST EVERYTHING EVERYTIME\n    // // Test DEBUG\n    // const pDevTest0 = this.#configTester.testEsriFeatureWithForestIndustry();\n    // // const pDevTest2 = this.#configTester.testKMLBadUrlExpectSkip();\n\n    // // Resolve when all\n    // return Promise.all([pDevTest0]);\n    // // GV END DEBUG SECTION TO NOT HAVE TO TEST EVERYTHING EVERYTIME\n\n    // Test EsriDynamic HistoricalFloodconfig\n    const pEsriDynamicHistoFlood = this.#configTester.testEsriDynamicWithHistoricalFloodEvents();\n\n    // Test EsriDynamic CESI config\n    const pEsriDynamicCESI = this.#configTester.testEsriDynamicWithCESI();\n\n    // Test a true negative\n    const pEsriDynamicBadUrl = this.#configTester.testEsriDynamicBadUrl();\n\n    // Test EsriFeature TorontoNeighbourhoods config\n    const pEsriFeatureToronto = this.#configTester.testEsriFeatureWithTorontoNeighbourhoods();\n\n    // Test EsriFeature HistoricalFloodEvents config\n    const pEsriFeatureHisto = this.#configTester.testEsriFeatureWithHistoricalFloodEvents();\n\n    // Test EsriFeature Forest Industry config\n    const pEsriFeatureForest = this.#configTester.testEsriFeatureWithForestIndustry();\n\n    // Test a true negative\n    const pEsriFeatureBadUrl = this.#configTester.testEsriFeatureBadUrl();\n\n    // Test EsriImage Elevation config\n    const pEsriImage = this.#configTester.testEsriImageWithElevation();\n\n    // Test a true negative\n    const pEsriImageBadUrl = this.#configTester.testEsriImageBadUrl();\n\n    // Test WMS OWSMundialis config\n    const pWMSMundialis = this.#configTester.testWMSLayerWithOWSMundialis();\n\n    // Test WMS DatacubeMSI config\n    const pWMSDatacubeMSI = this.#configTester.testWMSLayerWithDatacubeMSI();\n\n    // Test a true negative\n    const pWMSBadUrl = this.#configTester.testWMSBadUrl();\n\n    // Test WFS CurrentCondition config\n    const pWFSCurrentConditions = this.#configTester.testWFSLayerWithGeometCurrentConditions();\n\n    // Test a true negative\n    const pWFSBadUrl = this.#configTester.testWFSBadUrl();\n\n    // Test a true negative\n    const pWFSOkayUrlNoCap = this.#configTester.testWFSOkayUrlNoCap();\n\n    // Test OGC Feature config\n    const pOGcFeature = this.#configTester.testOGCFeatureWithPygeoapi();\n\n    // Test a true negative\n    const pOgcFeatureBadUrl = this.#configTester.testOGCFeatureBadUrl();\n\n    // Test a GeoJSON Metadata.meta config\n    const pGeoJson = this.#configTester.testGeojsonWithMetadataMeta();\n\n    // Test a skip\n    const pGeoJsonBadUrlSkip = this.#configTester.testGeoJSONBadUrlExpectSkip();\n\n    // Test a true negative\n    const pGeoJsonBadUrlFail = this.#configTester.testGeoJSONBadUrlExpectError();\n\n    // Test a CSV file\n    const pCSV = this.#configTester.testCSVWithStationList();\n\n    // Test a skip\n    const pCSVBadUrlSkip = this.#configTester.testCSVBadUrlExpectSkip();\n\n    // Test a WKB file\n    const pWKB = this.#configTester.testWKBWithSouthAfrica();\n\n    // Test a true negative\n    const pWKBBadUrlFail = this.#configTester.testWKBBadUrlExpectFail();\n\n    // Test a KML file\n    const pKMLTornado = this.#configTester.testKMLWithTornado();\n\n    // Test a skip\n    const pKMLSkip = this.#configTester.testKMLBadUrlExpectSkip();\n\n    // Test a Geocore\n    const pGeocoreAirborne = this.#configTester.testStandaloneGeocoreWithAirborne();\n\n    // Resolve when all\n    return Promise.all([\n      pEsriDynamicHistoFlood,\n      pEsriDynamicCESI,\n      pEsriDynamicBadUrl,\n      pEsriFeatureToronto,\n      pEsriFeatureHisto,\n      pEsriFeatureForest,\n      pEsriFeatureBadUrl,\n      pEsriImage,\n      pEsriImageBadUrl,\n      pWMSMundialis,\n      pWMSDatacubeMSI,\n      pWMSBadUrl,\n      pWFSCurrentConditions,\n      pWFSBadUrl,\n      pWFSOkayUrlNoCap,\n      pOGcFeature,\n      pOgcFeatureBadUrl,\n      pGeoJson,\n      pGeoJsonBadUrlSkip,\n      pGeoJsonBadUrlFail,\n      pCSV,\n      pCSVBadUrlSkip,\n      pWKB,\n      pWKBBadUrlFail,\n      pKMLTornado,\n      pKMLSkip,\n      pGeocoreAirborne,\n    ]);\n  }\n}\n","import { Test } from '../core/test';\nimport { GVAbstractTester } from './abstract-gv-tester';\nimport type { MapViewer } from 'geoview-core/geo/map/map-viewer';\nimport { LayerStatusErrorError } from 'geoview-core/core/exceptions/layer-exceptions';\nimport { LayerNoCapabilitiesError, LayerServiceMetadataUnableToFetchError } from 'geoview-core/core/exceptions/layer-exceptions';\nimport type { TypeGeoviewLayerConfig } from 'geoview-core/api/types/layer-schema-types';\nimport type { AbstractGVLayer } from 'geoview-core/geo/layer/gv-layers/abstract-gv-layer';\nimport { EsriDynamic } from 'geoview-core/geo/layer/geoview-layers/raster/esri-dynamic';\nimport { generateId } from 'geoview-core/core/utils/utilities';\nimport { LegendEventProcessor } from 'geoview-core/api/event-processors/event-processor-children/legend-event-processor';\nimport { EsriFeature } from 'geoview-core/geo/layer/geoview-layers/vector/esri-feature';\nimport { EsriImage } from 'geoview-core/geo/layer/geoview-layers/raster/esri-image';\nimport { WMS } from 'geoview-core/geo/layer/geoview-layers/raster/wms';\nimport { WFS } from 'geoview-core/geo/layer/geoview-layers/vector/wfs';\nimport { GeoJSON } from 'geoview-core/geo/layer/geoview-layers/vector/geojson';\nimport { CSV } from 'geoview-core/geo/layer/geoview-layers/vector/csv';\nimport { OgcFeature } from 'geoview-core/geo/layer/geoview-layers/vector/ogc-feature';\nimport { WKB } from 'geoview-core/geo/layer/geoview-layers/vector/wkb';\nimport { KML } from 'geoview-core/geo/layer/geoview-layers/vector/kml';\nimport type { GeoViewLayerAddedResult } from 'geoview-core/geo/layer/layer';\n\n/**\n * Main Layer testing class.\n * @extends {GVAbstractTester}\n */\nexport class LayerTester extends GVAbstractTester {\n  /**\n   * Returns the name of the Tester.\n   * @returns {string} The name of the Tester.\n   */\n  override getName(): string {\n    return 'LayerTester';\n  }\n\n  // #region ESRI DYNAMIC\n\n  /**\n   * Tests adding an Esri Dynamic Historical Flood Events layer on the map.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddEsriDynamicHistoFloodEvents(): Promise<Test<AbstractGVLayer>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.HISTORICAL_FLOOD_URL_MAP_SERVER;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.HISTORICAL_FLOOD_URL_LAYER_ID;\n    const gvLayerName = 'Esri Dynamic Histo Flood Events';\n\n    // Test\n    return this.test(\n      `Test Adding Esri Dynamic Histo Flood Events on map...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = EsriDynamic.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [\n          { id: GVAbstractTester.HISTORICAL_FLOOD_URL_LAYER_ID },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing an Esri Dynamic layer configuration using an invalid metadata URL.\n   * This test verifies that when an Esri Dynamic layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerServiceMetadataUnableToFetchError}.\n   * @returns {Promise<Test<LayerServiceMetadataUnableToFetchError>>}\n   * A promise that resolves with the test result, expecting a `LayerServiceMetadataUnableToFetchError`.\n   */\n  testAddEsriDynamicBadUrl(): Promise<Test<LayerServiceMetadataUnableToFetchError>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.BAD_URL;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.HISTORICAL_FLOOD_URL_LAYER_ID;\n    const gvLayerName = 'Esri Dynamic Histo Flood Events';\n\n    // Test\n    return this.testError(\n      `Test Adding Esri Dynamic with bad url...`,\n      LayerServiceMetadataUnableToFetchError,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = EsriDynamic.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [\n          { id: GVAbstractTester.HISTORICAL_FLOOD_URL_LAYER_ID },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n      },\n      undefined,\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerConfigAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a Geocore layer pointing to an Esri Dynamic layer containing Raster Layers.\n   * @returns {Promise<Test<AbstractGVLayer>>}\n   * A promise that resolves with the test result, expecting a `AbstractGVLayer`.\n   */\n  testAddEsriDynamicWithRasterLayersViaGeocore(): Promise<Test<AbstractGVLayer>> {\n    const gvLayerId = GVAbstractTester.ESRI_DYNAMIC_LABOUR_FORCE_UUID;\n    const layerPathGroup = gvLayerId + '/' + GVAbstractTester.ESRI_DYNAMIC_LABOUR_FORCE_GROUP;\n    const layerPathPetroleum = gvLayerId + '/' + GVAbstractTester.ESRI_DYNAMIC_LABOUR_FORCE_PETROLEUM;\n    const layerPathMinerals = gvLayerId + '/' + GVAbstractTester.ESRI_DYNAMIC_LABOUR_FORCE_MINERALS;\n    const layerPathForestry = gvLayerId + '/' + GVAbstractTester.ESRI_DYNAMIC_LABOUR_FORCE_FORESTRY;\n    const layerPathFisheries = gvLayerId + '/' + GVAbstractTester.ESRI_DYNAMIC_LABOUR_FORCE_FISHERIES;\n    const layerPathAgriculture = gvLayerId + '/' + GVAbstractTester.ESRI_DYNAMIC_LABOUR_FORCE_AGRICULTURE;\n    const layerPathCanecumene = gvLayerId + '/' + GVAbstractTester.ESRI_DYNAMIC_LABOUR_FORCE_CANECUMENE;\n\n    // Test\n    return this.test(\n      `Test Adding Esri Dynamic with Raster Layers via Geocore...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMapFromUUID(test, this.getMapViewer(), gvLayerId);\n\n        // Find the layer and wait until its ready\n        await LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPathPetroleum);\n        await LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPathMinerals);\n        await LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPathForestry);\n        await LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPathFisheries);\n        await LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPathAgriculture);\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPathCanecumene);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPathPetroleum);\n        LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPathMinerals);\n        LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPathForestry);\n        LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPathFisheries);\n        LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPathAgriculture);\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPathCanecumene);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPathGroup);\n      }\n    );\n  }\n\n  // #endregion ESRI DYNAMIC\n\n  // #region ESRI FEATURE\n\n  /**\n   * Tests adding an Esri Feature Forest Industry layer on the map.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddEsriFeatureForestIndustry(): Promise<Test<AbstractGVLayer>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.FOREST_INDUSTRY_MAP_SERVER;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.FOREST_INDUSTRY_LAYER_ID;\n    const gvLayerName = 'Esri Feature Forest Industry';\n\n    // Test\n    return this.test(\n      `Test Adding Esri Feature Forest Industry on map...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = EsriFeature.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [\n          { id: GVAbstractTester.FOREST_INDUSTRY_LAYER_ID },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing an Esri Feature layer configuration using an invalid metadata URL.\n   * This test verifies that when an Esri Feature layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerServiceMetadataUnableToFetchError}.\n   * @returns {Promise<Test<LayerServiceMetadataUnableToFetchError>>}\n   * A promise that resolves with the test result, expecting a `LayerServiceMetadataUnableToFetchError`.\n   */\n  testAddEsriFeatureBadUrl(): Promise<Test<LayerServiceMetadataUnableToFetchError>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.BAD_URL;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.FOREST_INDUSTRY_LAYER_ID;\n    const gvLayerName = 'Esri Feature Forest Industry';\n\n    // Test\n    return this.testError(\n      `Test Adding Esri Feature with bad url...`,\n      LayerServiceMetadataUnableToFetchError,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = EsriFeature.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [\n          { id: GVAbstractTester.FOREST_INDUSTRY_LAYER_ID },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n      },\n      undefined,\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerConfigAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  // #endregion ESRI FEATURE\n\n  // #region ESRI IMAGE\n\n  /**\n   * Tests adding an Esri Feature Forest Industry layer on the map.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddEsriImageWithElevation(): Promise<Test<AbstractGVLayer>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.IMAGE_SERVER_ELEVATION_URL;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.IMAGE_SERVER_ELEVATION_LAYER_ID;\n    const gvLayerName = 'Esri Image Elevation';\n\n    // Test\n    return this.test(\n      `Test Adding Esri Image Elevation on map...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = EsriImage.createGeoviewLayerConfigSimple(gvLayerId, gvLayerName, layerUrl, false);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests adding an Esri Feature Forest Industry layer on the map.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddEsriImageWithUSA(): Promise<Test<AbstractGVLayer>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.IMAGE_SERVER_USA_URL;\n    const layerPathGroup = gvLayerId + '/base-group';\n    const layerPathCities = gvLayerId + '/base-group/' + GVAbstractTester.IMAGE_SERVER_USA_LAYER_ID_CITIES;\n    const layerPathRoads = gvLayerId + '/base-group/' + GVAbstractTester.IMAGE_SERVER_USA_LAYER_ID_ROADS;\n    const gvLayerName = 'Esri Image USA';\n\n    // Test\n    return this.test(\n      `Test Adding Esri Image USA on map...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = EsriImage.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [\n          {\n            id: GVAbstractTester.IMAGE_SERVER_USA_LAYER_ID_CITIES,\n            layerName: 'Cities',\n          },\n          {\n            id: GVAbstractTester.IMAGE_SERVER_USA_LAYER_ID_ROADS,\n            layerName: 'Roads',\n          },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        await LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPathCities);\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPathRoads);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPathCities);\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPathRoads);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPathGroup);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing an Esri Image layer configuration using an invalid metadata URL.\n   * This test verifies that when an Esri Image layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerServiceMetadataUnableToFetchError}.\n   * @returns {Promise<Test<LayerServiceMetadataUnableToFetchError>>}\n   * A promise that resolves with the test result, expecting a `LayerServiceMetadataUnableToFetchError`.\n   */\n  testAddEsriImageBadUrl(): Promise<Test<LayerServiceMetadataUnableToFetchError>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.BAD_URL + '/' + GVAbstractTester.IMAGE_SERVER_ELEVATION_LAYER_ID + '/ImageServer'; // Has to be formatted like this, because we're guessing the layer id with url parsing!\n    const layerPath = gvLayerId + '/' + GVAbstractTester.IMAGE_SERVER_ELEVATION_LAYER_ID;\n    const gvLayerName = 'Esri Image Elevation';\n\n    // Test\n    return this.testError(\n      `Test Adding Esri Image with bad url...`,\n      LayerServiceMetadataUnableToFetchError,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = EsriImage.createGeoviewLayerConfigSimple(gvLayerId, gvLayerName, layerUrl, false);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n      },\n      undefined,\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerConfigAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  // #endregion ESRI IMAGE\n\n  // #region WMS\n\n  /**\n   * Tests adding an Esri Feature Forest Industry layer on the map.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddWMSLayerWithOWSMundialis(): Promise<Test<AbstractGVLayer>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.OWS_MUNDIALIS;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.OWS_MUNDIALIS_LAYER_ID;\n    const gvLayerName = 'OWS Mundialis';\n    const hasStyle: boolean = false;\n\n    // Test\n    return this.test(\n      `Test Adding WMS Mundialis on map...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = WMS.createGeoviewLayerConfig(\n          gvLayerId,\n          gvLayerName,\n          layerUrl,\n          'mapserver',\n          false,\n          [{ id: GVAbstractTester.OWS_MUNDIALIS_LAYER_ID }],\n          false\n        );\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath, hasStyle);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPath, hasStyle);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests adding an Esri Feature Forest Industry layer on the map.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddWMSLayerWithDatacubeMSI(): Promise<Test<AbstractGVLayer>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.DATACUBE_MSI;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.DATACUBE_MSI_LAYER_NAME_MSI_OR_MORE;\n    const gvLayerName = 'Datacube MSI';\n    const hasStyle: boolean = false;\n\n    // Test\n    return this.test(\n      `Test Adding WMS Datacube MSI on map...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = WMS.createGeoviewLayerConfig(\n          gvLayerId,\n          gvLayerName,\n          layerUrl,\n          'mapserver',\n          false,\n          [{ id: GVAbstractTester.DATACUBE_MSI_LAYER_NAME_MSI_OR_MORE }],\n          false\n        );\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath, hasStyle);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPath, hasStyle);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests adding an Esri Feature Forest Industry layer on the map.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddWMSLayerWithDatacubeRingOfFire(): Promise<Test<AbstractGVLayer>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.DATACUBE_RING_FIRE;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.DATACUBE_RING_FIRE_LAYER_ID_HALIFAX;\n    const gvLayerName = 'Halifax';\n    const hasStyle: boolean = false;\n\n    // Test\n    return this.test(\n      `Test Adding WMS Datacube Ring of Fire XML Halifax on map...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = WMS.createGeoviewLayerConfig(\n          gvLayerId,\n          gvLayerName,\n          layerUrl,\n          'mapserver',\n          false,\n          [{ id: GVAbstractTester.DATACUBE_RING_FIRE_LAYER_ID_HALIFAX }],\n          false\n        );\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath, hasStyle);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPath, hasStyle);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a WMS layer configuration using an invalid metadata URL.\n   * This test verifies that when an WMS layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerNoCapabilitiesError}.\n   * @returns {Promise<Test<LayerNoCapabilitiesError>>}\n   * A promise that resolves with the test result, expecting a `LayerNoCapabilitiesError`.\n   */\n  testAddWMSBadUrl(): Promise<Test<LayerNoCapabilitiesError>> {\n    // GV: In the case of a WMS, since a proxy is used when the url fails, and that proxy always returns a 200 response (with an internal error inside)\n    // GV: We can't really test the LayerServiceMetadataUnableToFetchError error exception.\n\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.BAD_URL;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.DATACUBE_MSI_LAYER_NAME_MSI_OR_MORE;\n    const gvLayerName = 'Datacube MSI';\n\n    // Test\n    return this.testError(\n      `Test Adding WMS with bad url...`,\n      LayerNoCapabilitiesError,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = WMS.createGeoviewLayerConfig(\n          gvLayerId,\n          gvLayerName,\n          layerUrl,\n          'mapserver',\n          false,\n          [{ id: GVAbstractTester.DATACUBE_MSI_LAYER_NAME_MSI_OR_MORE }],\n          false\n        );\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n      },\n      undefined,\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerConfigAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  // #endregion WMS\n\n  // #region WFS\n\n  /**\n   * Tests adding an WFS with Geomet Current Conditions layer on the map.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddWFSLayerWithWithGeometCurrentConditions(): Promise<Test<AbstractGVLayer>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.GEOMET_URL;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.GEOMET_URL_CURRENT_COND_LAYER_ID;\n    const gvLayerName = 'Current Conditions';\n\n    // Test\n    return this.test(\n      `Test Adding WFS with Geomet Current Conditions layer on map...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = WFS.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, 'all', [\n          { id: GVAbstractTester.GEOMET_URL_CURRENT_COND_LAYER_ID },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a WMS layer configuration using an invalid metadata URL.\n   * This test verifies that when an WMS layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerServiceMetadataUnableToFetchError}.\n   * @returns {Promise<Test<LayerServiceMetadataUnableToFetchError>>}\n   * A promise that resolves with the test result, expecting a `LayerServiceMetadataUnableToFetchError`.\n   */\n  testAddWFSBadUrl(): Promise<Test<LayerServiceMetadataUnableToFetchError>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.BAD_URL;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.GEOMET_URL_CURRENT_COND_LAYER_ID;\n    const gvLayerName = 'Current Conditions';\n\n    // Test\n    return this.testError(\n      `Test Adding WFS with bad url...`,\n      LayerServiceMetadataUnableToFetchError,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = WFS.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, 'all', [\n          { id: GVAbstractTester.GEOMET_URL_CURRENT_COND_LAYER_ID },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n      },\n      undefined,\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerConfigAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a WFS layer configuration using an invalid metadata URL.\n   * This test verifies that when an WFS layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerNoCapabilitiesError}.\n   * @returns {Promise<Test<LayerNoCapabilitiesError>>}\n   * A promise that resolves with the test result, expecting a `LayerNoCapabilitiesError`.\n   */\n  testAddWFSOkayUrlNoCap(): Promise<Test<LayerNoCapabilitiesError>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.FAKE_URL_ALWAYS_RETURNING_RESPONSE_INSTEAD_OF_NETWORK_ERROR;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.GEOMET_URL_CURRENT_COND_LAYER_ID;\n    const gvLayerName = 'Current Conditions';\n\n    // Test\n    return this.testError(\n      `Test Adding WFS with okay url no capabilities...`,\n      LayerNoCapabilitiesError,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = WFS.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, 'all', [\n          { id: GVAbstractTester.GEOMET_URL_CURRENT_COND_LAYER_ID },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n      },\n      undefined,\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerConfigAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  // #endregion WFS\n\n  // #region GeoJSON\n\n  /**\n   * Tests adding a GeoJSON with Polygons layer on the map.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddGeoJSONWithMetadataPolygons(): Promise<Test<AbstractGVLayer>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.GEOJSON_METADATA_META;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.GEOJSON_POLYGONS;\n    const gvLayerName = 'Polygons JSON';\n\n    // Test\n    return this.test(\n      `Test Adding GeoJSON with Metadata layer on map...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = GeoJSON.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [\n          { id: GVAbstractTester.GEOJSON_POLYGONS },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a GeoJSON layer configuration using an invalid metadata URL.\n   * This test verifies that when a GeoJSON layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerStatusErrorError}.\n   * @returns {Promise<Test<LayerStatusErrorError>>}\n   * A promise that resolves with the test result, expecting a `LayerStatusErrorError`.\n   */\n  testAddGeoJSONBadUrl(): Promise<Test<LayerStatusErrorError>> {\n    // GV: In the case of a GeoJSON, since we don't validate the url until we try to fetch the data,\n    // GV: we have to wait until the layer gets on the map and throws an error, which will since the layer can't reach the data.\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.BAD_URL;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.GEOJSON_POLYGONS;\n    const gvLayerName = 'Polygons JSON';\n\n    // Test\n    return this.testError(\n      `Test Adding GeoJSON with bad url...`,\n      LayerStatusErrorError,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = GeoJSON.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [\n          { id: GVAbstractTester.GEOJSON_POLYGONS },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        await LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath);\n      },\n      undefined,\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerConfigAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  // #endregion GeoJSON\n\n  // #region CSV\n\n  /**\n   * Tests adding a CSV with Station List layer on the map.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddCSVWithStationList(): Promise<Test<AbstractGVLayer>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.CSV_STATION_LIST;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.CSV_STATION_LIST_FILE;\n    const gvLayerName = 'Station List CSV';\n\n    // Test\n    return this.test(\n      `Test Adding a CSV with Station List layer on map...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = CSV.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [\n          { id: GVAbstractTester.CSV_STATION_LIST_FILE },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a CSV layer configuration using an invalid metadata URL.\n   * This test verifies that when a CSV layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerStatusErrorError}.\n   * @returns {Promise<Test<LayerStatusErrorError>>}\n   * A promise that resolves with the test result, expecting a `LayerStatusErrorError`.\n   */\n  testAddCSVWithBadUrl(): Promise<Test<LayerStatusErrorError>> {\n    // GV: In the case of a CSV, since we don't validate the url until we try to fetch the data,\n    // GV: we have to wait until the layer gets on the map and throws an error, which will since the layer can't reach the data.\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.BAD_URL;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.CSV_STATION_LIST_FILE;\n    const gvLayerName = 'Station List CSV';\n\n    // Test\n    return this.testError(\n      `Test Adding CSV with bad url...`,\n      LayerStatusErrorError,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = CSV.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [\n          { id: GVAbstractTester.CSV_STATION_LIST_FILE },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        await LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath);\n      },\n      undefined,\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerConfigAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  // #endregion CSV\n\n  // #region OGC Feature\n\n  /**\n   * Tests adding an OGC Feature layer with Pygeoapi on the map.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddOGCFeatureWithPygeoapi(): Promise<Test<AbstractGVLayer>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.PYGEOAPI_B6RYUVAKK5;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.PYGEOAPI_B6RYUVAKK5_LAKES;\n    const gvLayerName = GVAbstractTester.PYGEOAPI_B6RYUVAKK5_LAKES;\n\n    // Test\n    return this.test(\n      `Test Adding an OGC Feature with Pygeoapi layer on map...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = OgcFeature.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [\n          { id: GVAbstractTester.PYGEOAPI_B6RYUVAKK5_LAKES },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPath);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing an OGC Feature layer configuration using an invalid metadata URL.\n   * This test verifies that when an OGC Feature layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerServiceMetadataUnableToFetchError}.\n   * @returns {Promise<Test<LayerServiceMetadataUnableToFetchError>>}\n   * A promise that resolves with the test result, expecting a `LayerServiceMetadataUnableToFetchError`.\n   */\n  testAddOGCFeatureWithBadUrl(): Promise<Test<LayerServiceMetadataUnableToFetchError>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.BAD_URL;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.PYGEOAPI_B6RYUVAKK5_LAKES;\n    const gvLayerName = GVAbstractTester.PYGEOAPI_B6RYUVAKK5_LAKES;\n\n    // Test\n    return this.testError(\n      `Test Adding OGC Feature with bad url...`,\n      LayerServiceMetadataUnableToFetchError,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = OgcFeature.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [\n          { id: GVAbstractTester.PYGEOAPI_B6RYUVAKK5_LAKES },\n        ]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n      },\n      undefined,\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerConfigAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  // #endregion OGC Feature\n\n  // #region WKB\n\n  /**\n   * Tests adding a WKB with South Africa on the map.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddWKBWithSouthAfrica(): Promise<Test<AbstractGVLayer>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.WKB_SOUTH_AFRICA;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.WKB_SOUTH_AFRICA;\n    const gvLayerName = 'WKB South Africa';\n    const hasStyle: boolean = false;\n\n    // Test\n    return this.test(\n      `Test Adding a WKB with South Africa layer on map...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = WKB.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [{ id: GVAbstractTester.WKB_SOUTH_AFRICA }]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath, hasStyle);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPath, hasStyle);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing an WKB layer configuration using an invalid metadata URL.\n   * This test verifies that when an WKB layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerStatusErrorError}.\n   * @returns {Promise<Test<LayerStatusErrorError>>}\n   * A promise that resolves with the test result, expecting a `LayerStatusErrorError`.\n   */\n  testAddWKBWithBadUrl(): Promise<Test<LayerStatusErrorError>> {\n    // GV: In the case of a WKB, since we don't validate the url until we try to fetch the data,\n    // GV: we have to wait until the layer gets on the map and throws an error, which will since the layer can't reach the data.\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.BAD_URL;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.WKB_SOUTH_AFRICA;\n    const gvLayerName = GVAbstractTester.WKB_SOUTH_AFRICA;\n\n    // Test\n    return this.testError(\n      `Test Adding WKB with bad url...`,\n      LayerStatusErrorError,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = WKB.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [{ id: GVAbstractTester.WKB_SOUTH_AFRICA }]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        await LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath);\n      },\n      undefined,\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerConfigAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  // #endregion WKB\n\n  // #region KML\n\n  /**\n   * Tests adding a KML with Tornado on the map.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddKMLWithTornado(): Promise<Test<AbstractGVLayer>> {\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.KML_TORNADO;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.KML_TORNADO_FILE;\n    const gvLayerName = 'KML Tornado';\n    const hasStyle: boolean = false;\n\n    // Test\n    return this.test(\n      `Test Adding a KML with Tornado layer on map...`,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = KML.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [{ id: GVAbstractTester.KML_TORNADO_FILE }]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        return LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath, hasStyle);\n      },\n      (test) => {\n        // Perform assertions\n        // Redirect to helper to check if the layer exists\n        return LayerTester.helperStepAssertLayerExists(test, this.getMapViewer(), layerPath, hasStyle);\n      },\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests the behavior of initializing a KML layer configuration using an invalid metadata URL.\n   * This test verifies that when a KML layer configuration is initialized with an invalid or unreachable\n   * metadata URL, the initialization process fails as expected and throws a\n   * {@link LayerStatusErrorError}.\n   * @returns {Promise<Test<LayerStatusErrorError>>}\n   * A promise that resolves with the test result, expecting a `LayerStatusErrorError`.\n   */\n  testAddKMLWithBadUrl(): Promise<Test<LayerStatusErrorError>> {\n    // GV: In the case of a KML, since we don't validate the url until we try to fetch the data,\n    // GV: we have to wait until the layer gets on the map and throws an error, which will since the layer can't reach the data.\n    // Create a random geoview layer id\n    const gvLayerId = generateId();\n    const layerUrl = GVAbstractTester.BAD_URL;\n    const layerPath = gvLayerId + '/' + GVAbstractTester.KML_TORNADO_FILE;\n    const gvLayerName = GVAbstractTester.KML_TORNADO_FILE;\n\n    // Test\n    return this.testError(\n      `Test Adding KML with bad url...`,\n      LayerStatusErrorError,\n      async (test) => {\n        // Creating the configuration\n        test.addStep('Creating the GeoView Layer Configuration...');\n\n        // Create the config\n        const gvConfig = KML.createGeoviewLayerConfig(gvLayerId, gvLayerName, layerUrl, false, [{ id: GVAbstractTester.KML_TORNADO_FILE }]);\n\n        // Redirect to helper to add the layer to the map and wait\n        await LayerTester.helperStepAddLayerOnMap(test, this.getMapViewer(), gvConfig);\n\n        // Find the layer and wait until its ready\n        await LayerTester.helperStepCheckLayerAtLayerPath(test, this.getMapViewer(), layerPath);\n      },\n      undefined,\n      (test) => {\n        // Redirect to helper to clean up and assert\n        LayerTester.helperFinalizeStepRemoveLayerConfigAndAssert(test, this.getMapViewer(), layerPath);\n      }\n    );\n  }\n\n  // #endregion KML\n\n  // #region HELPERS\n\n  /**\n   * Adds a GeoView layer to the map, waits for it to load completely, and returns the loaded layer instance.\n   * Each step of the process is logged into the provided test instance for traceability and debugging.\n   * @param {Test<AbstractGVLayer>} test - The test instance used to log each step in the layer setup process.\n   * @param {MapViewer} mapViewer - The map viewer to which the layer will be added.\n   * @param {TypeGeoviewLayerConfig} gvConfig - The configuration object defining the GeoView layer to be added.\n   * @returns {Promise<GeoViewLayerAddedResult>} A promise that resolves to the fully loaded GeoView layer instance.\n   * @static\n   */\n  static async helperStepAddLayerOnMap<T>(\n    test: Test<T>,\n    mapViewer: MapViewer,\n    gvConfig: TypeGeoviewLayerConfig\n  ): Promise<GeoViewLayerAddedResult> {\n    // Adding the layer on the map\n    test.addStep('Adding the layer on the map...');\n\n    // Add the geoview layer by geocore uuid\n    const result = mapViewer.layer.addGeoviewLayer(gvConfig);\n\n    // Creating the configuration\n    test.addStep('Waiting for the layer to be added...');\n\n    // Wait for the layer to be fully added on the map\n    await result.promiseLayer;\n\n    // Throw if errors\n    result.layer.throwAggregatedLayerLoadErrors();\n\n    // Return the layer\n    return result;\n  }\n\n  /**\n   * Adds a GeoView layer to the map, waits for it to load completely, and returns the loaded layer instance.\n   * Each step of the process is logged into the provided test instance for traceability and debugging.\n   * @param {Test<AbstractGVLayer>} test - The test instance used to log each step in the layer setup process.\n   * @param {MapViewer} mapViewer - The map viewer to which the layer will be added.\n   * @param {TypeGeoviewLayerConfig} gvConfig - The configuration object defining the GeoView layer to be added.\n   * @returns {Promise<GeoViewLayerAddedResult | void>} A promise that resolves to the fully loaded GeoView layer instance.\n   * @static\n   */\n  static async helperStepAddLayerOnMapFromUUID<T>(\n    test: Test<T>,\n    mapViewer: MapViewer,\n    uuid: string\n  ): Promise<GeoViewLayerAddedResult | void> {\n    // Adding the layer on the map\n    test.addStep('Adding the layer on the map...');\n\n    // Add the geoview layer by geocore uuid\n    const result = await mapViewer.layer.addGeoviewLayerByGeoCoreUUID(uuid);\n\n    // Creating the configuration\n    test.addStep('Waiting for the layer to be added...');\n\n    // Wait for the layer to be fully added on the map\n    await result?.promiseLayer;\n\n    // Throw if errors\n    result?.layer.throwAggregatedLayerLoadErrors();\n\n    // Return the layer\n    return result;\n  }\n\n  /**\n   * Adds a GeoView layer to the map, waits for it to load completely, and returns the loaded layer instance.\n   * Each step of the process is logged into the provided test instance for traceability and debugging.\n   * @param {TypeGeoviewLayerConfig} gvConfig - The configuration object defining the GeoView layer to be added.\n   * @param {Test<AbstractGVLayer>} test - The test instance used to log each step in the layer setup process.\n   * @param {MapViewer} mapViewer - The map viewer to which the layer will be added.\n   * @param {string} layerPath - The unique path or ID used to retrieve the added layer from the map viewer.\n   * @param {boolean} [waitStyle] - Indicates if should wait for the style to be applied (expecting a style icon). Default: true.\n   * @returns {Promise<AbstractGVLayer>} A promise that resolves to the fully loaded GeoView layer instance.\n   * @static\n   */\n  static async helperStepCheckLayerAtLayerPath<T>(\n    test: Test<T>,\n    mapViewer: MapViewer,\n    layerPath: string,\n    waitStyle: boolean = true\n  ): Promise<AbstractGVLayer> {\n    // Creating the configuration\n    test.addStep(`Find the layer ${layerPath} on the map...`);\n\n    // Get the layer\n    const layer = mapViewer.layer.getGeoviewLayer(layerPath) as AbstractGVLayer;\n\n    // Creating the configuration\n    test.addStep(`Waiting for the layer to be loaded...`);\n\n    // Wait until the layer has at least loaded once\n    await layer.waitLoadedOnce();\n\n    // Wait until the legend has been fetched\n    test.addStep(`Wait for the legend to be fetched...`);\n    await layer.waitLegendFetched();\n\n    // Wait until the style has been applied\n    if (waitStyle) {\n      test.addStep(`Wait for the style to be applied...`);\n      await layer.waitStyleApplied();\n    }\n\n    // Return the layer\n    return layer;\n  }\n\n  /**\n   * Asserts that a layer with the given path exists in the map's legend store.\n   * Logs the verification step in the test instance.\n   * @param {Test<AbstractGVLayer>} test - The test instance used to record the verification step.\n   * @param {MapViewer} mapViewer - The map viewer instance containing the layer store.\n   * @param {string} layerPath - The path or ID of the layer to verify.\n   * @param {boolean} [checkStyle] - Indicates if should check that a style has been applied (a style icon was expected). Default: true.\n   * @static\n   */\n  static helperStepAssertLayerExists(\n    test: Test<AbstractGVLayer>,\n    mapViewer: MapViewer,\n    layerPath: string,\n    checkStyle: boolean = true\n  ): void {\n    // Get the layer legend\n    const legendLayer = LegendEventProcessor.getLegendLayerInfo(mapViewer.mapId, layerPath);\n\n    // Verify the layer has a legend information\n    test.addStep(`Verify the layer ${layerPath} has legend information...`);\n    Test.assertIsDefined('legendLayer', legendLayer);\n\n    // If checking the style\n    if (checkStyle) {\n      // Redirect\n      this.helperStepAssertStyleApplied(test, mapViewer, layerPath);\n    }\n  }\n\n  /**\n   * Asserts that a layer with the given path has icons for its style.\n   * Logs the verification step in the test instance.\n   * @param {Test<AbstractGVLayer>} test - The test instance used to record the verification step.\n   * @param {MapViewer} mapViewer - The map viewer instance containing the layer store.\n   * @param {string} layerPath - The path or ID of the layer to verify.\n   * @static\n   */\n  static helperStepAssertStyleApplied(test: Test<AbstractGVLayer>, mapViewer: MapViewer, layerPath: string): void {\n    // Get the layer legend from the store\n    const legendLayer = LegendEventProcessor.getLegendLayerInfo(mapViewer.mapId, layerPath);\n\n    // Verify the icon were also loaded for the layer\n    test.addStep(`Verify the icons were loaded for the layer...`);\n    Test.assertIsArrayLengthMinimal(legendLayer?.icons, 1);\n\n    // Take the first one\n    const firstIcon = legendLayer!.icons[0];\n    const hasStyleIcon = firstIcon.iconImage && firstIcon.iconImage !== 'no data';\n    Test.assertIsEqual(hasStyleIcon, true);\n  }\n\n  /**\n   * Removes a layer from the map using its path and asserts that it no longer exists in the legend store.\n   * Each step is logged to the provided test instance for traceability.\n   * @param {Test<AbstractGVLayer>} test - The test instance used to record each step of the removal process.\n   * @param {MapViewer} mapViewer - The map viewer instance from which the layer is removed.\n   * @param {string} layerPath - The unique path or ID of the layer to be removed.\n   * @static\n   */\n  static helperFinalizeStepRemoveLayerAndAssert<T>(test: Test<T>, mapViewer: MapViewer, layerPath: string): void {\n    // Check that the layer is indeed there\n    test.addStep(`Checking the layer path ${layerPath} exists on the map...`);\n    Test.assertArrayIncludes(mapViewer.layer.getGeoviewLayerPaths(), layerPath);\n\n    // Remove the added layer\n    test.addStep(`Removing the layer ${layerPath} from the map...`);\n    mapViewer.layer.removeLayerUsingPath(layerPath);\n\n    // Check the removal worked\n    test.addStep(`Check that the layer is indeed removed...`);\n    const legendLayers = LegendEventProcessor.getLegendLayers(mapViewer.mapId);\n    Test.assertArrayExcludes(\n      legendLayers.map((legendLayer) => legendLayer.layerPath),\n      layerPath\n    );\n  }\n\n  /**\n   * Removes a layer from the map using its path and asserts that it no longer exists in the legend store.\n   * Each step is logged to the provided test instance for traceability.\n   * @param {Test<AbstractGVLayer>} test - The test instance used to record each step of the removal process.\n   * @param {MapViewer} mapViewer - The map viewer instance from which the layer is removed.\n   * @param {string} geoviewLayerId - The geoview layer id of the layer config to be removed.\n   * @static\n   */\n  static helperFinalizeStepRemoveLayerConfigAndAssert<T>(test: Test<T>, mapViewer: MapViewer, geoviewLayerId: string): void {\n    // Check that the layer is indeed there\n    test.addStep(`Checking the geoview layer ${geoviewLayerId} exists on the map...`);\n    Test.assertIsDefined('layerEntryConfig ' + geoviewLayerId, mapViewer.layer.getLayerEntryConfigIfExists(geoviewLayerId));\n\n    // Remove the added layer\n    test.addStep(`Removing the geoview layer ${geoviewLayerId} from the map...`);\n    mapViewer.layer.removeLayerUsingPath(geoviewLayerId);\n\n    // Validate that it's gone\n    test.addStep(`Validate that the layer is indeed gone...`);\n    Test.assertIsUndefined('layerEntryConfig ' + geoviewLayerId, mapViewer.layer.getLayerEntryConfigIfExists(geoviewLayerId));\n  }\n\n  // #endregion HELPERS\n}\n","import type { Coordinate } from 'ol/coordinate';\nimport { AbstractTester } from '../core/abstract-tester';\nimport type { API } from 'geoview-core/api/api';\nimport type { MapViewer } from 'geoview-core/geo/map/map-viewer';\n\n/**\n * Main GeoView Abstract Tester class.\n * @extends {AbstractTester}\n */\nexport abstract class GVAbstractTester extends AbstractTester {\n  /** GLOBAL CONSTANTS FOR THE TESTS */\n\n  /** Some long lat coordinates for map investigations */\n  static readonly QUEBEC_LONLAT: Coordinate = [-71.356054449131, 46.78077550041052];\n  static readonly MANITOBA_CENTER_LONLAT: Coordinate = [-86.73558298224057, 50.833271435899974];\n\n  /** Bad url */\n  static BAD_URL = 'https://badurl/oops';\n\n  /**\n   * Fake url acting like a WMS/WFS url for a GetCapabilities call - the proxy is a good url to use to fake this.\n   * Something like https://google.ca will get turned into https://google.ca/?service=WFS&request=GetCapabilities and that's\n   * not a 200 response and we can't test with that.\n   * Not using the core config url constant on purpose, because it serves a whole different purpose here.\n   */\n  static FAKE_URL_ALWAYS_RETURNING_RESPONSE_INSTEAD_OF_NETWORK_ERROR = 'https://maps.canada.ca/wmsproxy/ws/wmsproxy/executeFromProxy';\n\n  /** Airborne Radioactivity uuid */\n  static AIRBORNE_RADIOACTIVITY_UUID: string = '21b821cf-0f1c-40ee-8925-eab12d357668';\n  static AIRBORNE_RADIOACTIVITY_GROUP: string = GVAbstractTester.AIRBORNE_RADIOACTIVITY_UUID + '/0';\n  static AIRBORNE_RADIOACTIVITY_UUID_WITH_SUFFIX: string = GVAbstractTester.AIRBORNE_RADIOACTIVITY_UUID + '/0/1';\n  static AIRBORNE_RADIOACTIVITY_LAYER_GROUP_NAME: string = 'Airborne Radioactivity';\n\n  /** Historical Flood */\n  static readonly HISTORICAL_FLOOD_URL_MAP_SERVER: string =\n    'https://maps-cartes.services.geo.ca/server_serveur/rest/services/NRCan/historical_flood_event_en/MapServer';\n  static readonly HISTORICAL_FLOOD_URL_LAYER_ID: string = '0';\n  static readonly HISTORICAL_FLOOD_LAYER_NAME: string = 'Historical Flood Events';\n\n  static readonly HISTORICAL_FLOOD_URL_FEATURE_SERVER: string =\n    GVAbstractTester.HISTORICAL_FLOOD_URL_MAP_SERVER + '/' + GVAbstractTester.HISTORICAL_FLOOD_URL_LAYER_ID;\n\n  /** Forest Industry Hotspots */\n  static readonly FOREST_INDUSTRY_MAP_SERVER: string =\n    'https://maps-cartes.services.geo.ca/server_serveur/rest/services/NRCan/forest_industry_hotspots_en/MapServer';\n  static readonly FOREST_INDUSTRY_LAYER_ID: string = '0';\n  static readonly FOREST_INDUSTRY_LAYER_NAME: string = 'Location of mill facilities';\n  static readonly FOREST_INDUSTRY_FEATURE_SERVER: string =\n    GVAbstractTester.FOREST_INDUSTRY_MAP_SERVER + '/' + GVAbstractTester.FOREST_INDUSTRY_LAYER_ID;\n\n  /** EsriDynamic with Raster Layers */\n  static readonly ESRI_DYNAMIC_LABOUR_FORCE_UUID: string = 'ac2096a6-7b4a-464e-9e08-eca7873dd88c';\n  static readonly ESRI_DYNAMIC_LABOUR_FORCE_GROUP: string = '0';\n  static readonly ESRI_DYNAMIC_LABOUR_FORCE_PETROLEUM: string = '0/1';\n  static readonly ESRI_DYNAMIC_LABOUR_FORCE_MINERALS: string = '0/2';\n  static readonly ESRI_DYNAMIC_LABOUR_FORCE_FORESTRY: string = '0/3';\n  static readonly ESRI_DYNAMIC_LABOUR_FORCE_FISHERIES: string = '0/4';\n  static readonly ESRI_DYNAMIC_LABOUR_FORCE_AGRICULTURE: string = '0/5';\n  static readonly ESRI_DYNAMIC_LABOUR_FORCE_CANECUMENE: string = '0/6';\n\n  /** CESI */\n  static readonly CESI_MAP_SERVER: string = 'https://maps-cartes.ec.gc.ca/arcgis/rest/services/CESI/MapServer';\n  static readonly CESI_GROUP_0_LAYER_NAME: string = 'Water quantity';\n\n  /** Toronto */\n  static readonly FEATURE_SERVER_TORONTO_NEIGHBOURHOODS_URL: string =\n    'https://services.arcgis.com/V6ZHFr6zdgNZuVG0/ArcGIS/rest/services/Toronto_Neighbourhoods/FeatureServer';\n  static readonly FEATURE_SERVER_TORONTO_NEIGHBOURHOODS_LAYER_NAME: string = 'Toronto_Neighbourhoods';\n\n  /** Elevation */\n  static readonly IMAGE_SERVER_ELEVATION_URL: string =\n    'https://ws.geoservices.lrc.gov.on.ca/arcgis5/rest/services/Elevation/FRI_CHM_SPL/ImageServer';\n  static readonly IMAGE_SERVER_ELEVATION_LAYER_ID: string = 'FRI_CHM_SPL';\n\n  /** USA Image Server */\n  static readonly IMAGE_SERVER_USA_URL: string = 'https://sampleserver6.arcgisonline.com/ArcGIS/rest/services/USA/MapServer';\n  static readonly IMAGE_SERVER_USA_LAYER_ID_CITIES: string = '0';\n  static readonly IMAGE_SERVER_USA_LAYER_ID_ROADS: string = '1';\n\n  /** OWS Mundialis */\n  static readonly OWS_MUNDIALIS: string = 'https://ows.mundialis.de/services/service'; // NOTE: Doesn't support EPSG:3978\n  static readonly OWS_MUNDIALIS_LAYER_ID: string = 'Dark';\n\n  /** Datacube MSI */\n  static readonly DATACUBE_MSI: string = 'https://datacube.services.geo.ca/ows/msi';\n  static readonly DATACUBE_MSI_LAYER_NAME_MSI: string = 'msi';\n  static readonly DATACUBE_MSI_LAYER_NAME_MSI_OR_MORE: string = 'msi-94-or-more';\n  static readonly DATACUBE_MSI_LAYERS_MSI_GET_CAP: string =\n    GVAbstractTester.DATACUBE_MSI + '?request=GetCapabilities&amp;service=wms&amp;version=1.3.0&amp;layers=msi';\n\n  static readonly DATACUBE_RING_FIRE: string = 'https://datacube.services.geo.ca/web/aerial.xml';\n  static readonly DATACUBE_RING_FIRE_LAYER_ID_HALIFAX: string = 'halifax';\n  static readonly DATACUBE_RING_FIRE_LAYER_ID_VICTORIA: string = 'victoria';\n\n  /** Geomet */\n  static readonly GEOMET_URL: string = 'https://geo.weather.gc.ca/geomet';\n  static readonly GEOMET_URL_CURRENT_COND_LAYER_ID: string = 'ec-msc:CURRENT_CONDITIONS';\n\n  /** Geojson */\n  static readonly GEOJSON_METADATA_META: string =\n    'https://canadian-geospatial-platform.github.io/geoview/public/datasets/geojson/metadata.meta';\n  static readonly GEOJSON_METADATA_META_FILE: string = 'metadata.meta';\n  static readonly GEOJSON_POLYGONS: string = 'polygons.json';\n\n  static readonly CSV_STATION_LIST: string =\n    'https://canadian-geospatial-platform.github.io/geoview/public/datasets/csv-files/Station_List_Minus_HQ-MELCC.csv';\n  static readonly CSV_STATION_LIST_FILE: string = 'Station_List_Minus_HQ-MELCC.csv';\n\n  static readonly PYGEOAPI_B6RYUVAKK5: string = 'https://b6ryuvakk5.execute-api.us-east-1.amazonaws.com/dev';\n  static readonly PYGEOAPI_B6RYUVAKK5_LAKES: string = 'lakes';\n\n  static readonly WKB_SOUTH_AFRICA: string =\n    '0103000000010000000500000054E3A59BC4602540643BDF4F8D1739C05C8FC2F5284C4140EC51B81E852B34C0D578E926316843406F1283C0CAD141C01B2FDD2406012B40A4703D0AD79343C054E3A59BC4602540643BDF4F8D1739C0';\n\n  static readonly KML_TORNADO: string =\n    'https://canadian-geospatial-platform.github.io/geoview/public/datasets/kml-files/CanadianNationalTornadoDatabase_1980-2009.kml';\n  static readonly KML_TORNADO_FILE: string = 'CanadianNationalTornadoDatabase_1980-2009.kml';\n\n  /** The API for the tests */\n  #api: API;\n\n  /** The Map Viewer for the tests */\n  #mapViewer: MapViewer;\n\n  /**\n   * Constructs a GeoView specific tester.\n   * @param {API} api - The api.\n   * @param {string} mapViewer - The map viewer.\n   */\n  constructor(api: API, mapViewer: MapViewer) {\n    super();\n\n    // Keep the attributes\n    this.#api = api;\n    this.#mapViewer = mapViewer;\n  }\n\n  /**\n   * Gets the shared api.\n   */\n  getApi(): API {\n    return this.#api;\n  }\n\n  /**\n   * Gets the MapViewer.\n   */\n  getMapViewer(): MapViewer {\n    return this.#mapViewer;\n  }\n\n  /**\n   * Gets the Map Id.\n   */\n  getMapId(): string {\n    return this.getMapViewer().mapId;\n  }\n}\n","import {\n  TestError,\n  AssertionJSONObjectError,\n  AssertionUndefinedError,\n  AssertionDefinedError,\n  AssertionValueError,\n  AssertionWrongInstanceError,\n  AssertionArrayExcludingError,\n  AssertionArrayIncludingError,\n  AssertionArrayLengthError,\n  AssertionArrayLengthMinimalError,\n  AssertionWrongErrorInstanceError,\n  AssertionNoErrorThrownError,\n} from './exceptions';\nimport type { TestStepLevel } from './test-step';\nimport { TestStep } from './test-step';\nimport type { EventDelegateBase } from 'geoview-core/api/events/event-helper';\nimport EventHelper from 'geoview-core/api/events/event-helper';\nimport { generateId } from 'geoview-core/core/utils/utilities';\n\nexport class Test<T = unknown> {\n  /** A unique id for the test */\n  id: string;\n\n  /** A title for the test */\n  #title: string;\n\n  /** The type of test (regular, true-negative) */\n  #type: TestType = 'regular';\n\n  /** The Steps the Test has processed so far */\n  #steps: TestStep[] = [];\n\n  /** The step status */\n  #status: TestStatus = 'new';\n\n  /** The assertion result when the test has executed its run. */\n  #result?: T;\n\n  /** The error which occurred during the test if any. */\n  #error?: Error;\n\n  /** Keep all callback delegate references */\n  #onStatusChangedHandlers: TestChangedDelegate[] = [];\n\n  /** Keep all callback delegate references */\n  #onStepChangedHandlers: TestChangedDelegate[] = [];\n\n  /**\n   * Constructs an {@link Test} instance.\n   * @param message - A message describing the test.\n   */\n  constructor(title: string) {\n    this.id = generateId();\n    this.#title = title;\n  }\n\n  /**\n   * Gets the current title.\n   * @returns {string} The title.\n   */\n  getTitle(): string {\n    return this.#title;\n  }\n\n  /**\n   * Sets the title.\n   * @param {string} title - The title to set.\n   */\n  setTitle(title: string): void {\n    this.#title = title;\n  }\n\n  /**\n   * Gets the current title.\n   * @returns {TestType} The title.\n   */\n  getType(): TestType {\n    return this.#type;\n  }\n\n  /**\n   * Sets the title.\n   * @param {TestType} type - The type to set.\n   */\n  setType(type: TestType): void {\n    this.#type = type;\n  }\n\n  /**\n   * Gets the current status of the test.\n   * @returns {string | undefined} The current step, or undefined if none is set.\n   */\n  getStatus(): TestStatus {\n    return this.#status;\n  }\n\n  /**\n   * Sets the current status of the test.\n   * @param {TestStatus} status - The status value to set.\n   */\n  setStatus(status: TestStatus): void {\n    this.#status = status;\n    this.#emitStatusChanged({ status });\n  }\n\n  /**\n   * Gets the step processed so far.\n   * @returns {TestStep[]} The steps processed so far.\n   */\n  getSteps(): TestStep[] {\n    return this.#steps;\n  }\n\n  /**\n   * Gets the steps formatted in html <ul> list.\n   * @returns {string} The steps formatted in html string.\n   */\n  getStepsAsHtml(): string {\n    const steps = this.getSteps();\n    if (steps.length === 0) return '';\n\n    let html = '<ul style=\"font-size: small;\">';\n\n    let currentMajorHtml = '';\n    let nestedSteps: string[] = [];\n\n    for (const step of steps) {\n      if (step.level === 'major') {\n        // If there's a previous major step, close it out\n        if (currentMajorHtml) {\n          if (nestedSteps.length > 0) {\n            currentMajorHtml += `<ul>${nestedSteps.join('')}</ul>`;\n          }\n          html += `<li>${currentMajorHtml}</li>`;\n          nestedSteps = [];\n        }\n        // Start a new major step\n        currentMajorHtml = `<strong><font style=\"color: ${step.color};\">${step.message}</font></strong>`;\n      } else {\n        // Accumulate nested steps\n        nestedSteps.push(`<li>${step.message}</li>`);\n      }\n    }\n\n    // Add the last major step (if any)\n    if (currentMajorHtml) {\n      if (nestedSteps.length > 0) {\n        currentMajorHtml += `<ul>${nestedSteps.join('')}</ul>`;\n      }\n      html += `<li>${currentMajorHtml}</li>`;\n    }\n\n    html += '</ul>';\n    return html;\n  }\n\n  /**\n   * Adds the step and emits a step change event.\n   * @param {string} step - The step value to add.\n   * @param {TypeStepLevel} level - The step level.\n   * @param {string} color - The step color for display purposes.\n   */\n  addStep(step: string, level: TestStepLevel = 'regular', color: string = 'black'): void {\n    this.#steps.push(new TestStep(step, level, color));\n    this.#emitStepChanged({ step });\n  }\n\n  /**\n   * Gets the assertion result associated with this instance.\n   * @returns {T | undefined} The assertion result, or undefined if not set.\n   */\n  getResult(): T | undefined {\n    return this.#result;\n  }\n\n  /**\n   * Sets the assertion result for this instance.\n   * @param {T} result - The result to associate.\n   */\n  setResult(result: T): void {\n    this.#result = result;\n  }\n\n  /**\n   * Gets the error which occurred during the test.\n   * @returns {Error | undefined} The error if any.\n   */\n  getError(): Error | undefined {\n    return this.#error;\n  }\n\n  /**\n   * Sets the error which occurred during the test..\n   * @param {Error} error - The error.\n   */\n  setError(error: Error): void {\n    this.#error = error;\n  }\n\n  // #region STATIC\n\n  /**\n   * Asserts that two values are strictly equal (`===`).\n   * @param {T} actualValue - The actual value being checked.\n   * @param {T} expectedValue - The expected value to compare against.\n   * @throws {AssertionError} If the values are not strictly equal.\n   * @static\n   */\n  static assertIsEqual<T = unknown>(actualValue: T, expectedValue: T): asserts actualValue is T {\n    // Checks if the result value is the same as the value provided\n    if (actualValue === expectedValue) return;\n\n    // Throw\n    throw new AssertionValueError(actualValue, expectedValue);\n  }\n\n  /**\n   * Asserts that a value is defined.\n   * @param {string} propertyPath - The name or path of the array being validated.\n   * @param {T | undefined} actualValue - The actual value being checked.\n   * @throws {AssertionUndefinedError} If the value isn't defined.\n   * @static\n   */\n  static assertIsDefined<T = unknown>(propertyPath: string, actualValue: T | undefined): void {\n    // Checks if the value is defined\n    if (actualValue !== undefined && actualValue !== null) return;\n\n    // Throw\n    throw new AssertionUndefinedError(propertyPath);\n  }\n\n  /**\n   * Asserts that a value is undefined.\n   * @param {string} propertyPath - The name or path of the array being validated.\n   * @param {T | undefined} actualValue - The actual value being checked.\n   * @throws {AssertionUndefinedError} If the value isn't defined.\n   * @static\n   */\n  static assertIsUndefined<T = unknown>(propertyPath: string, actualValue: T | undefined): void {\n    // Checks if the value is defined\n    if (actualValue === undefined || actualValue === null) return;\n\n    // Throw\n    throw new AssertionDefinedError(propertyPath, actualValue);\n  }\n\n  /**\n   * Asserts that a value is of the correct instance type.\n   * @param {unknown} actualValue - The actual value being checked.\n   * @param {Type<T>} expectedType - The expected class type.\n   * @throws {AssertionWrongInstanceError} If the value isn't defined.\n   * @static\n   */\n  static assertIsInstance<T>(actualValue: unknown, expectedType: ClassType<T>): asserts actualValue is T {\n    // Checks if the value is defined, first\n    Test.assertIsDefined('Object instance', actualValue);\n\n    // Checks if the value is of the expected instance type\n    if (actualValue instanceof expectedType) return;\n\n    // Throw\n    throw new AssertionWrongInstanceError(actualValue, expectedType);\n  }\n\n  /**\n   * Asserts that a value is of the correct instance type.\n   * @param {T} actualError - The actual error being checked.\n   * @param {Type<T>} expectedType - The expected class type.\n   * @throws {AssertionWrongInstanceError} If the value isn't defined.\n   * @static\n   */\n  static assertIsErrorInstance<T extends Error>(actualError: T, expectedType: ClassType<T>): asserts actualError is T {\n    // Checks if the value is defined, first\n    if (!actualError) throw new AssertionNoErrorThrownError(expectedType);\n\n    // Checks if the value is of the expected instance type\n    if (actualError instanceof expectedType) return;\n\n    // Throw\n    throw new AssertionWrongErrorInstanceError(actualError, expectedType);\n  }\n\n  /**\n   * Asserts that a length of a given array is equal to the expected length.\n   * @param {unknown[] | undefined} array - The array to check the length.\n   * @param {number} expectedValue - The expected length of the array.\n   * @throws {AssertionArrayLengthError} If the values are not strictly equal.\n   * @static\n   */\n  static assertIsArrayLengthEqual(array: unknown[] | undefined, expectedValue: number): void {\n    if (array?.length === expectedValue) return;\n\n    // Throw\n    throw new AssertionArrayLengthError(array?.length, expectedValue);\n  }\n\n  /**\n   * Asserts that a length of a given array is equal to the expected length.\n   * @param {unknown[] | undefined} array - The array to check the length.\n   * @param {number} expectedMinimumLength - The expected minimum length of the array.\n   * @throws {AssertionArrayLengthMinimalError} If the values are not strictly equal.\n   * @static\n   */\n  static assertIsArrayLengthMinimal(array: unknown[] | undefined, expectedMinimumLength: number): void {\n    if (array?.length ?? 0 >= expectedMinimumLength) return;\n\n    // Throw\n    throw new AssertionArrayLengthMinimalError(array?.length ?? 0, expectedMinimumLength);\n  }\n\n  /**\n   * Asserts that the given array includes the expected value.\n   * @template T - The type of the elements in the array.\n   * @param {T[]} array - The array to search.\n   * @param {T} expectedValue - The value expected to be included in the array.\n   * @throws {AssertionArrayNotIncludingError} Throws if the expected value is not found in the array.\n   */\n  static assertArrayIncludes<T = unknown>(array: T[], expectedValue: T): void {\n    if (array.includes(expectedValue)) return;\n\n    // Throw\n    throw new AssertionArrayIncludingError(array, expectedValue);\n  }\n\n  /**\n   * Asserts that the given array excludes a particular value.\n   * @template T - The type of the elements in the array.\n   * @param {T[]} array - The array to search.\n   * @param {T} expectedValue - The value expected to be included in the array.\n   * @throws {AssertionArrayNotIncludingError} Throws if the expected value is not found in the array.\n   */\n  static assertArrayExcludes<T = unknown>(array: T[], expectedValue: T): void {\n    if (!array.includes(expectedValue)) return;\n\n    // Throw\n    throw new AssertionArrayExcludingError(array, expectedValue);\n  }\n\n  /**\n   * Asserts that a JSON object has at least all the properties/values of the expected JSON object.\n   * @param {unknown} actualObject - The JSON object to check.\n   * @param {unknown} expectedObject - The JSON object to representing the properties/values the actual value should have.\n   * @throws {TestError} If the JSON object being verified is actually a Promise (likely a dev issue).\n   * @throws {AssertionJSONObjectError} If the JSON object being verified is missing properties or has different values.\n   * @static\n   */\n  static assertJsonObject(actualObject: unknown, expectedObject: unknown): void {\n    // If the object is a promise, throw error\n    if (actualObject instanceof Promise)\n      throw new TestError('The JSON object to verify is a promise, are you missing an await in your test process?');\n\n    // Compare the 2 json objects\n    const result = this.#jsonObjectIsAtLeast(actualObject as Record<string, unknown>, expectedObject as Record<string, unknown>);\n\n    // If not good\n    if (!result.ok) {\n      // Throw\n      throw new AssertionJSONObjectError(result.mismatches, actualObject, expectedObject);\n    }\n  }\n\n  /**\n   * Recursively checks that the `actual` object contains at least all properties and matching values\n   * from the `expected` object. Supports deeply nested structures and arrays.\n   * @param {Record<string, unknown>} actual - The object being validated.\n   * @param {Record<string, unknown>} expected - The minimum required shape and values.\n   * @param {string} basePath - Internal path tracker for nested mismatches (default: '').\n   * @returns An object with:\n   *   - `ok`: `true` if target meets/exceeds the reference\n   *   - `mismatches`: a list of string paths where mismatches occurred\n   * @example\n   * const actual = { user: { name: \"Alice\", roles: [\"admin\", \"editor\"] } };\n   * const expected = { user: { name: \"Alice\", roles: [\"admin\"] } };\n   * Returns: { ok: true, mismatches: [] }\n   *\n   * const actual = { user: { name: \"Bob\", roles: [\"editor\"] } };\n   * const expected = { user: { name: \"Alice\", roles: [\"admin\"] } };\n   * Returns:\n   * {\n   *   ok: false,\n   *   mismatches: [\n   *     'user.name  actual: \"Bob\", expected: \"Alice\"',\n   *     'user.roles[0]  actual: \"editor\", expected: \"admin\"'\n   *   ]\n   * }\n   * @private\n   * @static\n   */\n  static #jsonObjectIsAtLeast(\n    actual: Record<string, unknown>,\n    expected: Record<string, unknown>,\n    basePath: string = ''\n  ): ObjectAssertionResult {\n    // Array to collect all the paths where mismatches or missing data occur\n    const mismatches: string[] = [];\n\n    // Builds the current path string (e.g., \"user.name\" or \"roles[0]\")\n    const currentPath = (key: string | number): string => (basePath ? `${basePath}.${key}` : `${key}`);\n\n    // Handle primitive or null values: compare directly\n    if (typeof expected !== 'object' || expected === null) {\n      if (expected !== actual) {\n        // Record mismatch at current path\n        mismatches.push(`${basePath}  actual: ${JSON.stringify(actual)}, expected: ${JSON.stringify(expected)}`);\n      }\n      return {\n        ok: mismatches.length === 0,\n        mismatches,\n      };\n    }\n\n    // Handle arrays: ensure each reference item is matched by at least one target item\n    if (Array.isArray(expected)) {\n      if (!Array.isArray(actual)) {\n        // Target is not an array\n        mismatches.push(`${basePath}  actual: ${typeof actual}, expected an array`);\n        return {\n          ok: false,\n          mismatches,\n        };\n      }\n\n      // Each expected item must be matched by at least one item in the actual array\n      for (let i = 0; i < expected.length; i++) {\n        const expectedItem = expected[i];\n\n        let foundMatch = false;\n        let failedMismatches: string[] = [];\n\n        for (const actualItem of actual) {\n          const result = this.#jsonObjectIsAtLeast(actualItem, expectedItem, `${basePath}[${i}]`);\n          if (result.ok) {\n            foundMatch = true;\n            break;\n          } else if (failedMismatches.length === 0) {\n            // Save mismatches from the first failure to report if no match found\n            failedMismatches = result.mismatches;\n          }\n        }\n\n        if (!foundMatch) {\n          // Keep next line in case we want it back..\n          // mismatches.push(`${basePath}[${i}]  expected item not found: ${JSON.stringify(expectedItem)}`);\n          mismatches.push(...failedMismatches);\n        }\n      }\n      return {\n        ok: mismatches.length === 0,\n        mismatches,\n      };\n    }\n\n    // At this point, both reference and target are plain objects\n    if (typeof actual !== 'object' || actual === null || Array.isArray(actual)) {\n      mismatches.push(`${basePath}  actual: ${JSON.stringify(actual)}, expected an object`);\n      return { ok: false, mismatches };\n    }\n\n    // Recursively check each key in the reference object\n    for (const key of Object.keys(expected)) {\n      if (!(key in actual)) {\n        mismatches.push(`${currentPath(key)}  missing key, expected: ${JSON.stringify(expected[key])}`);\n      } else {\n        const childResult = this.#jsonObjectIsAtLeast(\n          actual[key] as Record<string, unknown>,\n          expected[key] as Record<string, unknown>,\n          currentPath(key)\n        );\n        mismatches.push(...childResult.mismatches);\n      }\n    }\n\n    return {\n      ok: mismatches.length === 0,\n      mismatches,\n    };\n  }\n\n  // #endregion\n\n  // #region EVENTS\n\n  /**\n   * Emits an event to all handlers.\n   * @param {StatusChangedEvent} event - The event to emit\n   * @private\n   */\n  #emitStatusChanged(event: StatusChangedEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onStatusChangedHandlers, event);\n  }\n\n  /**\n   * Registers a success event handler.\n   * @param {TestChangedDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onStatusChanged(callback: TestChangedDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onStatusChangedHandlers, callback);\n  }\n\n  /**\n   * Unregisters a success event handler.\n   * @param {TestChangedDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offStatusChanged(callback: TestChangedDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onStatusChangedHandlers, callback);\n  }\n\n  /**\n   * Emits an event to all handlers.\n   * @param {StepChangedEvent} event - The event to emit\n   * @private\n   */\n  #emitStepChanged(event: StepChangedEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onStepChangedHandlers, event);\n  }\n\n  /**\n   * Registers a success event handler.\n   * @param {TestChangedDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onStepChanged(callback: TestChangedDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onStepChangedHandlers, callback);\n  }\n\n  /**\n   * Unregisters a success event handler.\n   * @param {TestChangedDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offStepChanged(callback: TestChangedDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onStepChangedHandlers, callback);\n  }\n\n  // #endregion EVENTS\n}\n\n/**\n * Represents a constructor type that returns an instance of `T`.\n * This is useful when you need to pass around classes (constructors) generically,\n * such as for type assertions, factories, dependency injection, or reflection.\n * @template T - The type of the instance the constructor produces.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ClassType<T = unknown> = new (...args: any[]) => T;\n\n/**\n * Define a type for the result of a JSON object assertion check\n */\nexport type ObjectAssertionResult = { ok: boolean; mismatches: string[] };\n\n/**\n * Define a base event for the delegates\n */\nexport interface BaseTestChangedEvent {}\n\n/**\n * Define an event for the delegate\n */\nexport interface StepChangedEvent extends BaseTestChangedEvent {\n  step: string | undefined;\n}\n\n/**\n * Define an event for the delegate\n */\nexport interface StatusChangedEvent extends BaseTestChangedEvent {\n  status: TestStatus;\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type TestChangedDelegate = EventDelegateBase<Test, BaseTestChangedEvent, void>;\n\n/**\n * The test types\n */\nexport type TestType = 'regular' | 'true-negative';\n\n/**\n * The test statuses\n */\nexport type TestStatus = 'new' | 'running' | 'verifying' | 'success' | 'failed';\n","export class TestStep {\n  /**\n   * Constructs a TestStep.\n   * @param {string} message - The step message\n   */\n  constructor(\n    public message: string,\n    public level: TestStepLevel = 'regular',\n    public color: string = 'black'\n  ) {}\n}\n\n/**\n * The level of the Test Step.\n */\nexport type TestStepLevel = 'regular' | 'major';\n","import type { API } from 'geoview-core/api/api';\nimport type { MapViewer } from 'geoview-core/geo/map/map-viewer';\nimport { TestSuiteCannotExecuteError } from '../core/exceptions';\nimport { GVAbstractTester } from '../testers/abstract-gv-tester';\nimport { GeochartTester } from '../testers/geochart-tester';\nimport { GVAbstractTestSuite } from './abstract-gv-test-suite';\n\n/**\n * The GeoView Test Suite.\n */\nexport class GVTestSuiteGeochart extends GVAbstractTestSuite {\n  /** The Geochart Tester used in this Test Suite */\n  #geochartTester: GeochartTester;\n\n  /**\n   * Constructs the Test Suite\n   * @param {API} api - The shared api\n   * @param {MapViewer} mapViewer - The map viewer\n   */\n  constructor(api: API, mapViewer: MapViewer) {\n    super(api, mapViewer);\n\n    // Create the Geochart tester\n    this.#geochartTester = new GeochartTester(api, mapViewer);\n    this.addTester(this.#geochartTester);\n  }\n\n  /**\n   * Returns the name of the Test Suite.\n   * @returns {string} The name of the Test Suite.\n   */\n  override getName(): string {\n    return 'Geochart Test Suite';\n  }\n\n  /**\n   * Returns the description of the Test Suite.\n   * @returns {string} The description of the Test Suite.\n   */\n  override getDescriptionAsHtml(): string {\n    return 'Test Suite to perform various Geochart related tests.';\n  }\n\n  /**\n   * Overrides the check if the Test Suite can be executed.\n   * @returns {Promise<boolean>} A Promise resolving to true when the Test Suite can be launched for the given map.\n   */\n  protected override onCanExecuteTestSuite(): Promise<boolean> {\n    // Check if the geochart plugin is part of the corePackage on the testing map\n    const plugins = this.getMapViewer().mapFeaturesConfig.footerBar?.tabs?.core || [];\n    if (!plugins.includes('geochart'))\n      throw new TestSuiteCannotExecuteError(\n        'To run this Test Suite, the geochart plugin has to be loaded in the footerBar tabs core array.'\n      );\n\n    // All good\n    return Promise.resolve(true);\n  }\n\n  /**\n   * Overrides the implementation to perform the tests for this Test Suite.\n   * @returns {Promise<unknown>} A Promise which resolves when tests are completed.\n   */\n  protected override async onLaunchTestSuite(): Promise<unknown> {\n    // Test Geochart\n    const pGeochartPolygons = this.#geochartTester.testGeochartOpenForLayerMapClick(\n      'geojsonLYR5/polygons.json',\n      GVAbstractTester.MANITOBA_CENTER_LONLAT\n    );\n\n    // Wait for the test with polygons to complete\n    await pGeochartPolygons;\n\n    // Test Geochart\n    const pGeochartAirborne = this.#geochartTester.testAddGeocoreLayerUUIDForGeochartAirborne();\n\n    // Resolve when all\n    return Promise.all([pGeochartPolygons, pGeochartAirborne]);\n  }\n}\n","import type { Coordinate } from 'ol/coordinate';\nimport { Test } from '../core/test';\nimport { GVAbstractTester } from './abstract-gv-tester';\nimport { LayerTester } from './layer-tester';\nimport { delay } from 'geoview-core/core/utils/utilities';\nimport type { MapViewer } from 'geoview-core/geo/map/map-viewer';\nimport type { AbstractGVLayer } from 'geoview-core/geo/layer/gv-layers/abstract-gv-layer';\nimport { GeochartEventProcessor } from 'geoview-core/api/event-processors/event-processor-children/geochart-event-processor';\nimport { UIEventProcessor } from 'geoview-core/api/event-processors/event-processor-children/ui-event-processor';\n\n/**\n * Main Map testing class.\n * @extends {GVAbstractTester}\n */\nexport class GeochartTester extends GVAbstractTester {\n  /**\n   * Returns the name of the Tester.\n   * @returns {string} The name of the Tester.\n   */\n  override getName(): string {\n    return 'GeochartTester';\n  }\n\n  /**\n   * Tests opening the Geochart for a given layer path.\n   * @param {string} layerPath - The layer path of the layer.\n   * @param {Coordinate} lonlat - The coordinate on the map to query.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testGeochartOpenForLayerMapClick(layerPath: string, lonlat: Coordinate): Promise<Test<AbstractGVLayer>> {\n    // Test\n    return this.test(\n      `Test Geochart on layer ${layerPath}...`,\n      (test) => {\n        // Continue the test and return the layer\n        return GeochartTester.helperStepLayerWithGeochart(test, this.getMapViewer(), layerPath, lonlat);\n      },\n      (test) => {\n        // Perform assertions\n        // Check that geochart is the active footer bar\n        test.addStep(\"Verifying 'geochart' is the selected footer tab...\");\n        Test.assertIsEqual(UIEventProcessor.getActiveFooterBarTab(this.getMapId()), 'geochart');\n\n        // Check that layer path is selected\n        test.addStep('Verifying ' + layerPath + ' is the selected layer for the geochart...');\n        Test.assertIsEqual(GeochartEventProcessor.getSingleGeochartState(this.getMapId(), 'selectedLayerPath'), layerPath);\n      }\n    );\n  }\n\n  /**\n   * Tests adding a the Airborne Geocore layer, launching a query layers at a given lonlat, set the active footerbar tab to geochart and select the layer in the geochart panel.\n   * @returns {Promise<Test<AbstractGVLayer>>} A Promise resolving when the test completes.\n   */\n  testAddGeocoreLayerUUIDForGeochartAirborne(): Promise<Test<AbstractGVLayer>> {\n    // Test it\n    return this.testAddGeocoreLayerUUIDForGeochart(\n      GVAbstractTester.AIRBORNE_RADIOACTIVITY_UUID,\n      GVAbstractTester.AIRBORNE_RADIOACTIVITY_UUID_WITH_SUFFIX,\n      GVAbstractTester.AIRBORNE_RADIOACTIVITY_GROUP,\n      GVAbstractTester.QUEBEC_LONLAT,\n      {\n        [GVAbstractTester.AIRBORNE_RADIOACTIVITY_UUID_WITH_SUFFIX]: {\n          layers: [\n            {\n              layerId: GVAbstractTester.AIRBORNE_RADIOACTIVITY_UUID_WITH_SUFFIX,\n              propertyValue: 'Location_Emplacement',\n              propertyDisplay: 'OBJECTID',\n            },\n          ],\n          chart: 'line',\n          query: {\n            type: 'esriRegular',\n            url: 'https://maps-cartes.services.geo.ca/server_serveur/rest/services/HC/airborne_radioactivity_en/MapServer/3',\n            queryOptions: {\n              whereClauses: [\n                {\n                  field: 'Location_Emplacement',\n                  prefix: \"'\",\n                  valueFrom: 'Location_Emplacement',\n                  suffix: \"'\",\n                },\n              ],\n              orderByField: 'CollectionStart_DebutPrelevement',\n            },\n          },\n        },\n      }\n    );\n  }\n\n  /**\n   * Tests adding a Geocore layer, launching a query layers at a given lonlat, set the active footerbar tab to geochart and select the layer in the geochart panel.\n   * @param {string} uuid - The uuid of the Gecoore layer\n   * @param {string} layerPathAdd - The layer path of the layer that was added\n   * @param {string} layerPathRemove - The layer path of the layer to remove once the test terminates.\n   * @param {Coordinate} lonlat - The coordinate on the map to query.\n   * @param {Record<string, unknown>} expectedGeochartChartsConfig - The expected geochart charts configuration to validate.\n   * @returns\n   */\n  testAddGeocoreLayerUUIDForGeochart(\n    uuid: string,\n    layerPathAdd: string,\n    layerPathRemove: string,\n    lonlat: Coordinate,\n    expectedGeochartChartsConfig: Record<string, unknown>\n  ): Promise<Test<AbstractGVLayer>> {\n    // Test\n    return this.test(\n      'Test Geochart',\n      async (test) => {\n        // Update the step\n        test.addStep(`Adding the layer on the map for ${uuid}`);\n\n        // Add the geoview layer by geocore uuid\n        const result = await this.getMapViewer().layer.addGeoviewLayerByGeoCoreUUID(uuid);\n\n        // Update the step\n        test.addStep(`Adding the layer on the map...`);\n\n        // Wait for the layer to be processed (bit optional)\n        await result!.promiseLayer;\n\n        // Continue the test and return the layer\n        return GeochartTester.helperStepLayerWithGeochart(test, this.getMapViewer(), layerPathAdd, lonlat);\n      },\n      (test) => {\n        // Perform assertions\n        test.addStep('Verifying expected geochart config...');\n        const geochartsConfig = GeochartEventProcessor.getSingleGeochartState(this.getMapId(), 'geochartChartsConfig');\n        Test.assertJsonObject(geochartsConfig, expectedGeochartChartsConfig);\n\n        // Check that geochart is the active footer bar\n        test.addStep(\"Verifying 'geochart' is the selected footer tab...\");\n        Test.assertIsEqual(UIEventProcessor.getActiveFooterBarTab(this.getMapId()), 'geochart');\n\n        // Check that layer path is selected\n        test.addStep('Verifying ' + layerPathAdd + ' is the selected layer for the geochart...');\n        Test.assertIsEqual(GeochartEventProcessor.getSingleGeochartState(this.getMapId(), 'selectedLayerPath'), layerPathAdd);\n      },\n      (test) => {\n        // Redirect to LayerTest to help test the removal of the layer\n        LayerTester.helperFinalizeStepRemoveLayerAndAssert(test, this.getMapViewer(), layerPathRemove);\n      }\n    );\n  }\n\n  /**\n   * Retrieves a layer from the map, performs a feature info query at a specific coordinate,\n   * and sets up the geochart UI with that layer. Steps are logged to the provided test instance.\n   * @template T - The type parameter for the test instance.\n   * @param {Test<T>} test - The test instance used to log each step of the geochart setup process.\n   * @param {MapViewer} mapViewer - The map viewer containing the layer and UI context.\n   * @param {string} layerPath - The unique path or ID of the layer to interact with.\n   * @param {Coordinate} lonlat - The longitude/latitude coordinate at which to query the layer.\n   * @returns {Promise<AbstractGVLayer>} A promise that resolves to the layer after setup is complete.\n   * @static\n   */\n  static async helperStepLayerWithGeochart<T>(\n    test: Test<T>,\n    mapViewer: MapViewer,\n    layerPath: string,\n    lonlat: Coordinate\n  ): Promise<AbstractGVLayer> {\n    // Update the step\n    test.addStep(`Getting the layer with the geochart ${layerPath}...`);\n\n    // Get the layer\n    const layer = mapViewer.layer.getGeoviewLayer(layerPath) as AbstractGVLayer;\n\n    // Update the step\n    test.addStep(`Waiting for its layer 'loaded' status...`);\n\n    // Wait until the layer has at least loaded once\n    await layer.waitLoadedOnce();\n\n    // Update the step\n    test.addStep(`Perform query operation at given coordinates...`);\n\n    // Perform a map click using the feature info layer set\n    await mapViewer.layer.featureInfoLayerSet.queryLayers(lonlat);\n\n    // Update the step\n    test.addStep(`Setting active footerbar tab to geochart...`);\n\n    // Set the footer tab to Geochart\n    UIEventProcessor.setActiveFooterBarTab(mapViewer.mapId, 'geochart');\n\n    // Update the step\n    test.addStep(`Waiting on UI to refresh...`);\n\n    // Wait purposely on the UI, 2 seconds seem to be the minimum.. 1 second fails sometimes..\n    await delay(2000);\n\n    // Update the step\n    test.addStep(`Selecting the geochart for the added layer...`);\n\n    // Select the right layer path\n    GeochartEventProcessor.setSelectedGeochartLayerPath(mapViewer.mapId, layerPath);\n\n    // Wait purposely on the UI, this waiting period isn't necessary for the test, but it's good to see it happen in real-time\n    await delay(1000);\n\n    // Return the layer\n    return layer;\n  }\n}\n","import React from 'react'; // GV This import is to validate that we're on the right React at the end of the file\nimport { AbstractPlugin } from 'geoview-core/api/plugin/abstract-plugin';\nimport { PluginConfigNotFoundError, TestSuiteInitializationError } from 'geoview-core/core/exceptions/geoview-exceptions';\nimport type { EventDelegateBase } from 'geoview-core/api/events/event-helper';\nimport EventHelper from 'geoview-core/api/events/event-helper';\nimport type { TesterFailureEvent, TesterSuccessEvent, TesterTestEvent, TesterTestUpdatedEvent } from './tests/core/abstract-test-suite';\nimport { TestSuiteRunningError } from './tests/core/exceptions';\nimport type { GVAbstractTestSuite } from './tests/suites/abstract-gv-test-suite';\nimport { GVTestSuiteMapVaria } from './tests/suites/suite-map-varia';\nimport { GVTestSuiteConfig } from './tests/suites/suite-config';\nimport { GVTestSuiteGeochart } from './tests/suites/suite-geochart';\nimport { GVTestSuiteLayer } from './tests/suites/suite-layer';\n\n/**\n * Create a class for the plugin instance\n */\nclass TestSuitePlugin extends AbstractPlugin {\n  /** The Test Suites for the plugin */\n  testSuites: GVAbstractTestSuite[] = [];\n\n  /** Indicates the number of suites that completed their tests (the suites are run synchronously) */\n  #suitesCompleted: number = 0;\n\n  /** Keep all callback delegate references */\n  #onSuiteTestersTestStartedHandlers: SuiteTesterTestDelegate[] = [];\n\n  /** Keep all callback delegate references */\n  #onSuiteTestersTestUpdatedHandlers: SuiteTesterTestUpdatedDelegate[] = [];\n\n  /** Keep all callback delegate references */\n  #onSuiteTestersTestSuccessHandlers: SuiteTesterSuccessDelegate[] = [];\n\n  /** Keep all callback delegate references */\n  #onSuiteTestersTestFailureHandlers: SuiteTesterFailureDelegate[] = [];\n\n  /**\n   * Returns the package schema\n   *\n   * @returns {unknown} the package schema\n   */\n  override schema(): unknown {\n    return {};\n  }\n\n  /**\n   * Returns the default config for this package\n   *\n   * @returns {unknown} the default config\n   */\n  override defaultConfig(): unknown {\n    return {};\n  }\n\n  /**\n   * Overrides the default translations for the Plugin.\n   * @returns {Record<string, unknown>} - The translations object for the particular Plugin.\n   */\n  override defaultTranslations(): Record<string, unknown> {\n    return {};\n  }\n\n  /**\n   * Overrides the get config\n   * @override\n   * @returns {TestSuitePluginConfig} The config\n   */\n  override getConfig(): TestSuitePluginConfig {\n    return super.getConfig() as TestSuitePluginConfig;\n  }\n\n  /**\n   * Overrides the addition of the Test Suite Plugin.\n   */\n  override onAdd(): void {\n    // If the plugin has no configured test-suites, throw error\n    if (!this.getConfig().suites || this.getConfig().suites.length === 0)\n      throw new PluginConfigNotFoundError(this.pluginId, this.mapViewer.mapId, 'corePackagesConfig');\n\n    // For each defined suite\n    this.getConfig().suites.forEach((suite) => {\n      if (suite === 'suite-config') {\n        // Instanciate the GeoView Test Suite\n        this.addTestSuite(new GVTestSuiteConfig(window.cgpv.api, this.mapViewer));\n      } else if (suite === 'suite-map') {\n        // Instanciate the GeoView Test Suite\n        this.addTestSuite(new GVTestSuiteMapVaria(window.cgpv.api, this.mapViewer));\n      } else if (suite === 'suite-layer') {\n        // Instanciate the GeoView Test Suite\n        this.addTestSuite(new GVTestSuiteLayer(window.cgpv.api, this.mapViewer));\n      } else if (suite === 'suite-geochart') {\n        // Instanciate the GeoView Test Suite\n        this.addTestSuite(new GVTestSuiteGeochart(window.cgpv.api, this.mapViewer));\n      } else {\n        // Throw\n        throw new TestSuiteInitializationError(suite, this.mapViewer.mapId);\n      }\n    });\n  }\n\n  /**\n   * Overrides the removal of the Test Suite Plugin.\n   */\n  override onRemove(): void {} // Nothing to do\n\n  /**\n   * Adds a test suite to the manager and registers event handlers to track its lifecycle.\n   * When the test suite emits events such as test start, update, success, or failure,\n   * this method attaches listeners that re-emit those events through the manager's own system,\n   * augmenting them with the originating suite as additional context.\n   * @param {GVAbstractTestSuite} testSuite - The test suite instance to add and monitor.\n   */\n  addTestSuite(testSuite: GVAbstractTestSuite): void {\n    this.testSuites.push(testSuite);\n\n    // Register handlers when the a test has started\n    testSuite.onTestStarted((sender, event) => {\n      // Re-emit\n      this.#emitTestStarted({ ...event, suite: sender as GVAbstractTestSuite });\n    });\n\n    // Register handlers when the a test has updated\n    testSuite.onTestUpdated((sender, event) => {\n      // Re-emit\n      this.#emitTestUpdated({ ...event, suite: sender as GVAbstractTestSuite });\n    });\n\n    // Register handlers when the a test has succeeded\n    testSuite.onSuccess((sender, event) => {\n      // Re-emit\n      this.#emitSuccess({ ...event, suite: sender as GVAbstractTestSuite });\n    });\n\n    // Register handlers when the a test has failed\n    testSuite.onFailure((sender, event) => {\n      // Re-emit\n      this.#emitFailure({ ...event, suite: sender as GVAbstractTestSuite });\n    });\n  }\n\n  /**\n   * Launches all test suites sequentially.\n   * This method resets the completed suite counter, then executes each test suite\n   * one after the other (not in parallel). Awaits each suite to ensure sequential execution.\n   * @returns {Promise<void>} A promise that resolves once all test suites have completed.\n   */\n  async launchTestSuites(): Promise<void> {\n    // Make sure no test suite is currently running\n    if (this.getTestsRunning() > 0) throw new TestSuiteRunningError();\n\n    // Reset the test suites\n    this.resetTestSuites();\n\n    // For each test suite, launch them one by one and awaiting on them so they don't run in parallel\n    for (const testSuite of this.testSuites) {\n      // We do want to await in a loop so the test suites are launched sequencially\n      // eslint-disable-next-line no-await-in-loop\n      await testSuite.launchTestSuite();\n      // Increment the completed suites\n      this.#suitesCompleted++;\n    }\n  }\n\n  /**\n   * Resets all test suites and the internal completed suites counter.\n   * This is typically called to prepare for a new test run.\n   */\n  resetTestSuites(): void {\n    // Make sure no test suite is currently running\n    if (this.getTestsRunning() > 0) throw new TestSuiteRunningError();\n\n    // Reset the completed suites\n    this.#suitesCompleted = 0;\n\n    // Reset each test suite\n    this.testSuites.forEach((testSuite) => {\n      // Reset the test suite\n      testSuite.resetTestSuite();\n    });\n  }\n\n  /**\n   * Gets the description, in html format, for all the Test Suites part of this Plugin.\n   * @returns {string} The description of all test suites.\n   */\n  getDescriptionAsHtml(): string {\n    // For each Test Suite\n    return this.testSuites.map((suite) => suite.getDescriptionAsHtml()).join('<br/>');\n  }\n\n  /**\n   * Gets the number of test suites that have been completed.\n   * Caution, a test suite can be completed even though some tests are still running, depending\n   * on the promises management in the suite.\n   * @returns {number} The number of completed test suites.\n   */\n  getSuitesCompleted(): number {\n    return this.#suitesCompleted;\n  }\n\n  /**\n   * Gets the total number of test suites.\n   *@returns {number} The total count of test suites.\n   */\n  getSuitesTotal(): number {\n    return this.testSuites.length;\n  }\n\n  /**\n   * Gets if the test suite is done its launch.\n   * Caution, a test suite can be done even though some tests are still running, depending\n   * on the promises management in the suite.\n   * @returns {number} The number of completed test suites.\n   */\n  getSuitesDone(): boolean {\n    return this.getSuitesCompleted() === this.getSuitesTotal();\n  }\n\n  /**\n   * Gets the total number of tests currently running across all test suites.\n   * @returns {number} The number of tests that are currently running.\n   */\n  getTestsRunning(): number {\n    // For each test suite\n    return this.testSuites.reduce((total, testSuite) => {\n      return total + testSuite.getTestsRunning();\n    }, 0);\n  }\n\n  /**\n   * Gets the total number of tests completed across all test suites.\n   * @returns {number} The number of completed tests.\n   */\n  getTestsDone(): number {\n    // For each test suite\n    return this.testSuites.reduce((total, testSuite) => {\n      return total + testSuite.getTestsDone();\n    }, 0);\n  }\n\n  /**\n   * Gets the total number of currently done successfully across all test suites.\n   * @returns {number} The total number of tests done.\n   */\n  getTestsDoneSuccess(): number {\n    // For each test suite\n    return this.testSuites.reduce((total, testSuite) => {\n      return total + testSuite.getTestsDoneSuccess();\n    }, 0);\n  }\n\n  /**\n   * Gets the total number of currently done failed across all test suites\n   * @returns {number} The total number of tests done.\n   */\n  getTestsDoneFailed(): number {\n    // For each test suite\n    return this.testSuites.reduce((total, testSuite) => {\n      return total + testSuite.getTestsDoneFailed();\n    }, 0);\n  }\n\n  /**\n   * Gets the total number of tests across all test suites.\n   * @returns {number} The total number of tests.\n   */\n  getTestsTotal(): number {\n    // For each test suite\n    return this.testSuites.reduce((total, testSuite) => {\n      return total + testSuite.getTestsTotal();\n    }, 0);\n  }\n\n  /**\n   * Gets if all tests are done.\n   * @returns {boolean} Indicate if the tests are all done across all test suites.\n   */\n  getTestsDoneAll(): boolean {\n    return this.testSuites.every((suite) => suite.getTestsDoneAll());\n  }\n\n  /**\n   * Gets if all the tests are done across all test suites.\n   * @returns {boolean} Indicate if the tests are all done across all test suites.\n   */\n  getTestsDoneAllAndSuiteDone(): boolean {\n    return this.getSuitesDone() && this.getTestsDoneAll();\n  }\n\n  /**\n   * Gets if all the tests are done and successfully.\n   * @returns {boolean} Indicate if the tests are all done and finished successfully.\n   */\n  getTestsDoneAllSuccess(): boolean {\n    return this.getTestsDoneAll() && this.testSuites.every((suite) => suite.getTestsDoneAllSuccess());\n  }\n\n  /**\n   * Gets if all the tests are done and successfully and the test suite is done.\n   * @returns {boolean} Indicate if the tests are all done and finished successfully and the test suite is done.\n   */\n  getTestsDoneAllSuccessAndSuiteDone(): boolean {\n    return this.getSuitesDone() && this.getTestsDoneAllSuccess();\n  }\n\n  // #region EVENTS\n\n  /**\n   * Emits an event to all handlers.\n   * @param {SuiteTesterTestEvent} event - The event to emit\n   * @private\n   */\n  #emitTestStarted(event: SuiteTesterTestEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onSuiteTestersTestStartedHandlers, event);\n  }\n\n  /**\n   * Registers a test started event handler.\n   * @param {SuiteTesterTestDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onTestStarted(callback: SuiteTesterTestDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onSuiteTestersTestStartedHandlers, callback);\n  }\n\n  /**\n   * Unregisters a test started event handler.\n   * @param {SuiteTesterTestDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offTestStarted(callback: SuiteTesterTestDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onSuiteTestersTestStartedHandlers, callback);\n  }\n\n  /**\n   * Emits an event to all handlers.\n   * @param {SuiteTesterTestUpdatedEvent} event - The event to emit\n   * @private\n   */\n  #emitTestUpdated(event: SuiteTesterTestUpdatedEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onSuiteTestersTestUpdatedHandlers, event);\n  }\n\n  /**\n   * Registers a test updated event handler.\n   * @param {SuiteTesterTestUpdatedDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onTestUpdated(callback: SuiteTesterTestUpdatedDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onSuiteTestersTestUpdatedHandlers, callback);\n  }\n\n  /**\n   * Unregisters a test updated event handler.\n   * @param {SuiteTesterTestUpdatedDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offTestUpdated(callback: SuiteTesterTestUpdatedDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onSuiteTestersTestUpdatedHandlers, callback);\n  }\n\n  /**\n   * Emits an event to all handlers.\n   * @param {SuiteTesterSuccessEvent} event - The event to emit\n   * @private\n   */\n  #emitSuccess(event: SuiteTesterSuccessEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onSuiteTestersTestSuccessHandlers, event);\n  }\n\n  /**\n   * Registers a success event handler.\n   * @param {SuiteTesterSuccessDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onSuccess(callback: SuiteTesterSuccessDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onSuiteTestersTestSuccessHandlers, callback);\n  }\n\n  /**\n   * Unregisters a success event handler.\n   * @param {SuiteTesterSuccessDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offSuccess(callback: SuiteTesterSuccessDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onSuiteTestersTestSuccessHandlers, callback);\n  }\n\n  /**\n   * Emits an event to all handlers.\n   * @param {SuiteTesterFailureEvent} event - The event to emit\n   * @private\n   */\n  #emitFailure(event: SuiteTesterFailureEvent): void {\n    // Emit the event for all handlers\n    EventHelper.emitEvent(this, this.#onSuiteTestersTestFailureHandlers, event);\n  }\n\n  /**\n   * Registers a failure event handler.\n   * @param {SuiteTesterFailureDelegate} callback - The callback to be executed whenever the event is emitted\n   */\n  onFailure(callback: SuiteTesterFailureDelegate): void {\n    // Register the event handler\n    EventHelper.onEvent(this.#onSuiteTestersTestFailureHandlers, callback);\n  }\n\n  /**\n   * Unregisters a failure event handler.\n   * @param {SuiteTesterFailureDelegate} callback - The callback to stop being called whenever the event is emitted\n   */\n  offFailure(callback: SuiteTesterFailureDelegate): void {\n    // Unregister the event handler\n    EventHelper.offEvent(this.#onSuiteTestersTestFailureHandlers, callback);\n  }\n\n  // #endregion EVENTS\n}\n\n/**\n * Define an event for the delegate\n */\nexport interface SuiteTesterTestEvent extends TesterTestEvent {\n  suite: GVAbstractTestSuite;\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type SuiteTesterTestDelegate = EventDelegateBase<TestSuitePlugin, SuiteTesterTestEvent, void>;\n\n/**\n * Define an event for the delegate\n */\nexport interface SuiteTesterTestUpdatedEvent extends TesterTestUpdatedEvent {\n  suite: GVAbstractTestSuite;\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type SuiteTesterTestUpdatedDelegate = EventDelegateBase<TestSuitePlugin, SuiteTesterTestUpdatedEvent, void>;\n\n/**\n * Define an event for the delegate\n */\nexport interface SuiteTesterSuccessEvent extends TesterSuccessEvent {\n  suite: GVAbstractTestSuite;\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type SuiteTesterSuccessDelegate = EventDelegateBase<TestSuitePlugin, SuiteTesterSuccessEvent, void>;\n\n/**\n * Define an event for the delegate\n */\nexport interface SuiteTesterFailureEvent extends TesterFailureEvent {\n  suite: GVAbstractTestSuite;\n}\n\n/**\n * Define a delegate for the event handler function signature\n */\nexport type SuiteTesterFailureDelegate = EventDelegateBase<TestSuitePlugin, SuiteTesterFailureEvent, void>;\n\nexport type TestSuitePluginConfig = {\n  suites: string[];\n};\n\nexport default TestSuitePlugin;\n\n// GV This if condition took over 3 days to investigate. It was giving errors on the app.geo.ca website with\n// GV some conflicting reacts being loaded on the page for some obscure reason.\n// Check if we're on the right react\nif (React === window.cgpv.reactUtilities.react) {\n  // Keep a reference to the GeoChartPlugin as part of the geoviewPlugins property stored in the window object\n  window.geoviewPlugins = window.geoviewPlugins || {};\n  window.geoviewPlugins['test-suite'] = TestSuitePlugin;\n} // Else ignore, don't keep it on the window, wait for the right react load\n","import { TestError } from '../core/exceptions';\nimport { Test } from '../core/test';\nimport { GVAbstractTester } from './abstract-gv-tester';\nimport { delay } from 'geoview-core/core/utils/utilities';\nimport type { TypeMapState } from 'geoview-core/geo/map/map-viewer';\nimport type { TypeMapFeaturesConfig } from 'geoview-core/core/types/global-types';\nimport { MapEventProcessor } from 'geoview-core/api/event-processors/event-processor-children/map-event-processor';\n\n/**\n * Main Map testing class.\n * @extends {GVAbstractTester}\n */\nexport class MapTester extends GVAbstractTester {\n  /**\n   * Returns the name of the Tester.\n   * @returns {string} The name of the Tester.\n   */\n  override getName(): string {\n    return 'MapTester';\n  }\n\n  /**\n   * Tests the map state upon initial loading.\n   * @returns {Promise<Test<TypeMapState>>} A Promise that resolves with the Test containing the map state.\n   */\n  testMapState(): Promise<Test<TypeMapState>> {\n    // Get the projection\n    const { projection } = this.#getMapConfigFromStore().map.viewSettings;\n\n    // The expected map state configuration including the current projection\n    const expectedConfig: Record<string, unknown> = {\n      currentProjection: projection,\n    };\n\n    // GV Hard to test the zoom, because of other factors like view extent and such affecting the zoom compared to the config.\n    // // If the initial view had a specific zoom\n    // const zoom = this.getMapConfigFromStore().map.viewSettings.initialView?.zoomAndCenter?.[0];\n    // if (zoom) {\n    //   expectedConfig.currentZoom = zoom;\n    // }\n\n    // Test the map state\n    return this.test(\n      'Test projection',\n      () => {\n        // Return the map state\n        return MapEventProcessor.getMapState(this.getMapId());\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected projection config...');\n        Test.assertJsonObject(result, expectedConfig);\n      }\n    );\n  }\n\n  /**\n   * Tests a zoom operation on the map.\n   * @param {number} zoomEnd - The zoom target\n   * @param {number} zoomDuration - The duration for the zoom\n   * @returns {Promise<Test<number>>} A Promise that resolves with the Test containing the zoom destination.\n   */\n  testMapZoom(zoomEnd: number, zoomDuration: number): Promise<Test<number>> {\n    // Get the current zoom\n    const { currentZoom } = MapEventProcessor.getMapState(this.getMapId());\n\n    // Test the projection\n    return this.test(\n      'Test zoom',\n      async (test) => {\n        // Test the zoom value\n        if (currentZoom === zoomEnd) throw new TestError(`False precondition, map zoom was already at zoom destination ${zoomEnd}`);\n\n        // Update the step\n        test.addStep('Performing zoom...');\n\n        // Perform a zoom\n        MapEventProcessor.zoom(this.getMapId(), zoomEnd, zoomDuration);\n\n        // Update the step\n        test.addStep('Waiting for zoom to finish...');\n\n        // Wait for the zoom to end (1000 for store to update)\n        await delay(zoomDuration + 1000);\n\n        // Return the result\n        return zoomEnd;\n      },\n      (test, result) => {\n        // Perform assertions\n        test.addStep('Verifying expected zoom in the store...');\n        Test.assertIsEqual(MapEventProcessor.getMapState(this.getMapId()).currentZoom, result);\n      },\n      (test) => {\n        // Unzooms to original position\n        test.addStep('Unzooms to the original zoom...');\n        MapEventProcessor.zoom(this.getMapId(), currentZoom, zoomDuration);\n      }\n    );\n  }\n\n  /**\n   * Gets the map config from the store.\n   * @returns {TypeMapFeaturesConfig} The map config as read from the store.\n   */\n  #getMapConfigFromStore(): TypeMapFeaturesConfig {\n    // Redirect\n    const mapConfig = MapEventProcessor.getGeoViewMapConfig(this.getMapId());\n    if (!mapConfig) throw new TestError(`Map config for map id ${this.getMapId()} couldn't be read from store`);\n    return mapConfig;\n  }\n}\n","import type { API } from 'geoview-core/api/api';\nimport type { MapViewer } from 'geoview-core/geo/map/map-viewer';\nimport { GVAbstractTestSuite } from './abstract-gv-test-suite';\nimport { LayerTester } from '../testers/layer-tester';\n\n/**\n * The GeoView Test Suite.\n */\nexport class GVTestSuiteLayer extends GVAbstractTestSuite {\n  /** The Layer Tester used in this Test Suite */\n  #layerTester: LayerTester;\n\n  /**\n   * Constructs the Test Suite\n   * @param {API} api - The shared api\n   * @param {MapViewer} mapViewer - The map viewer\n   */\n  constructor(api: API, mapViewer: MapViewer) {\n    super(api, mapViewer);\n\n    // Create the Geocore tester\n    this.#layerTester = new LayerTester(api, mapViewer);\n    this.addTester(this.#layerTester);\n  }\n\n  /**\n   * Returns the name of the Test Suite.\n   * @returns {string} The name of the Test Suite.\n   */\n  override getName(): string {\n    return 'Layer Test Suite';\n  }\n\n  /**\n   * Returns the description of the Test Suite.\n   * @returns {string} The description of the Test Suite.\n   */\n  override getDescriptionAsHtml(): string {\n    return 'Test Suite to perform various layer related tests.';\n  }\n\n  /**\n   * Overrides the implementation to perform the tests for this Test Suite.\n   * @returns {Promise<unknown>} A Promise which resolves when tests are completed.\n   */\n  protected override onLaunchTestSuite(): Promise<unknown> {\n    // // GV START DEBUG SECTION TO NOT HAVE TO TEST EVERYTHING EVERYTIME\n    // // Test DEBUG\n    // const pDevTest0 = this.#layerTester.testAddEsriDynamicWithRasterLayersViaGeocore();\n    // // const pDevTest1 = this.#layerTester.testAddWKBWithBadUrl();\n    // // const pDevTest2 = this.#layerTester.testAddOGCFeatureWithPygeoapi();\n\n    // // Resolve when all\n    // return Promise.all([pDevTest0]);\n    // // GV END DEBUG SECTION TO NOT HAVE TO TEST EVERYTHING EVERYTIME\n\n    // Test adding layer\n    const pLayerEsriDynamicHistoFloods = this.#layerTester.testAddEsriDynamicHistoFloodEvents();\n\n    // Test adding layer EsriDynamic with Raster Layer inside, via Geocore UUID\n    const pLayerEsriDynamicWithRasterLayersViaGeocore = this.#layerTester.testAddEsriDynamicWithRasterLayersViaGeocore();\n\n    // Test true negative\n    const pLayerEsriDynamicBadUrl = this.#layerTester.testAddEsriDynamicBadUrl();\n\n    // Test adding layer\n    const pLayerEsriFeatureForestIndustry = this.#layerTester.testAddEsriFeatureForestIndustry();\n\n    // Test true negative\n    const pLayerEsriFeatureBadUrl = this.#layerTester.testAddEsriFeatureBadUrl();\n\n    // Test adding layer\n    const pLayerEsriImageElevation = this.#layerTester.testAddEsriImageWithElevation();\n\n    // Test true negative\n    const pLayerEsriImageBadUrl = this.#layerTester.testAddEsriImageBadUrl();\n\n    // Test adding layer\n    const pLayerWMSOWSMundialis = this.#layerTester.testAddWMSLayerWithOWSMundialis();\n\n    // Test adding layer\n    const pLayerWMSDatacubeOWSMSI = this.#layerTester.testAddWMSLayerWithDatacubeMSI();\n\n    // Test adding layer\n    const pLayerWMSDatacubeRingFireHalifax = this.#layerTester.testAddWMSLayerWithDatacubeRingOfFire();\n\n    // Test true negative\n    const pLayerWMSBadUrl = this.#layerTester.testAddWMSBadUrl();\n\n    // Test adding layer\n    const pLayerWFSWithGeometCurrentConditions = this.#layerTester.testAddWFSLayerWithWithGeometCurrentConditions();\n\n    // Test true negative\n    const pLayerWFSBadUrl = this.#layerTester.testAddWFSBadUrl();\n\n    // Test true negative\n    const pLayerWFSOkayUrlNoCap = this.#layerTester.testAddWFSOkayUrlNoCap();\n\n    // Test adding layer\n    const pLayerGeoJSONWithPolygons = this.#layerTester.testAddGeoJSONWithMetadataPolygons();\n\n    // Test true negative\n    const pLayerGeoJSonBadUrl = this.#layerTester.testAddGeoJSONBadUrl();\n\n    // Test adding layer\n    const pLayerCSVStationList = this.#layerTester.testAddCSVWithStationList();\n\n    // Test true negative\n    const pLayerCSVBadUrl = this.#layerTester.testAddCSVWithBadUrl();\n\n    // Test adding layer\n    const pLayerOGCFeatureWithPygeoapi = this.#layerTester.testAddOGCFeatureWithPygeoapi();\n\n    // Test true negative\n    const pLayerOGCFeatureBadUrl = this.#layerTester.testAddOGCFeatureWithBadUrl();\n\n    // Test adding layer\n    const pLayerWKBWithSouthAfrica = this.#layerTester.testAddWKBWithSouthAfrica();\n\n    // Test true negative\n    const pLayerWKBBadUrl = this.#layerTester.testAddWKBWithBadUrl();\n\n    // Test adding layer\n    const pLayerKMLWithTornado = this.#layerTester.testAddKMLWithTornado();\n\n    // Test true negative\n    const pLayerKMLBadUrl = this.#layerTester.testAddKMLWithBadUrl();\n\n    // Resolve when all\n    return Promise.all([\n      pLayerEsriDynamicHistoFloods,\n      pLayerEsriDynamicWithRasterLayersViaGeocore,\n      pLayerEsriDynamicBadUrl,\n      pLayerEsriFeatureForestIndustry,\n      pLayerEsriFeatureBadUrl,\n      pLayerEsriImageElevation,\n      pLayerEsriImageBadUrl,\n      pLayerWMSOWSMundialis,\n      pLayerWMSDatacubeOWSMSI,\n      pLayerWMSDatacubeRingFireHalifax,\n      pLayerWMSBadUrl,\n      pLayerWFSWithGeometCurrentConditions,\n      pLayerWFSBadUrl,\n      pLayerWFSOkayUrlNoCap,\n      pLayerGeoJSONWithPolygons,\n      pLayerGeoJSonBadUrl,\n      pLayerCSVStationList,\n      pLayerCSVBadUrl,\n      pLayerOGCFeatureWithPygeoapi,\n      pLayerOGCFeatureBadUrl,\n      pLayerWKBWithSouthAfrica,\n      pLayerWKBBadUrl,\n      pLayerKMLWithTornado,\n      pLayerKMLBadUrl,\n    ]);\n  }\n}\n"],"names":["_mapTester","WeakMap","GVTestSuiteMapVaria","_GVAbstractTestSuite","api","mapViewer","_this","_classCallCheck","_classPrivateFieldInitSpec","MapTester","addTester","_classPrivateFieldGet","_inherits","_createClass","key","value","pmapState","this","testMapState","pZoom","testMapZoom","Promise","all","GVAbstractTestSuite","_testers","_onTestersTestStartedHandlers","_onTestersTestUpdatedHandlers","_onTestersTestSuccessHandlers","_onTestersTestFailureHandlers","_AbstractTestSuite_brand","WeakSet","AbstractTestSuite","reduce","total","tester","getTestsTotal","getTestsRunning","getTestsDone","getTestsDoneSuccess","getTestsDoneFailed","every","getTestsDoneAll","getTestsDoneAllSuccess","push","onStarted","_assertClassBrand","_handleTesterTestStarted","bind","onStepUpdated","_handleTesterTestStepUpdated","onSuccess","_handleTesterSuccess","onFailure","_handleTesterFailure","_launchTestSuite","_asyncToGenerator","_regeneratorRuntime","_callee","_context","prev","next","TestSuiteRunningError","onCanExecuteTestSuite","sent","TestSuiteCannotExecuteError","abrupt","onLaunchTestSuite","stop","apply","arguments","forEach","resetTests","resolve","callback","EventHelper","onEvent","offEvent","sender","event","_emitTestStarted","call","_objectSpread","_emitTestUpdated","_emitSuccess","_emitFailure","emitEvent","_api","_mapViewer","_AbstractTestSuite","_classPrivateFieldSet","mapId","_onTestStartedHandlers","_onTestUpdatedHandlers","_onSuccessHandlers","_onFailureHandlers","_onDoneHandlers","_tests","_testsRunning","_testsDone","_AbstractTester_brand","AbstractTester","length","filter","test","getStatus","message","callbackAssert","callbackFinalize","_testPerformTest","errorClass","_testPerformTestError","Test","onStepChanged","_handleTestStepChanged","logger","logDebug","concat","getTitle","_addTestRunning","setStatus","addStep","_emitStarted","_emitStepChanged","result","error","duringFinalization","originalStatus","normalizedError","Error","String","setError","_moveTestFromRunningToDone","_emitDone","_x","_x2","_x3","_x4","_testPerformTest2","_result","_t","_t2","onCreatingTest","onPerformingTest","setResult","onPerformingTestAssertions","onPerformingTestSuccess","onPerformingTestFailure","onPerformingTestFinalization","onPerformingTestDone","_x5","_x6","_x7","_x8","_x9","_testPerformTestError2","_callee2","_result2","_t3","_t4","_t5","_context2","setType","undefined","formatError","assertIsErrorInstance","index","findIndex","t","id","splice","onPerformingTestStepChanged","TestError","_Error","_callSuper","name","captureStackTrace","Object","setPrototypeOf","prototype","_wrapNativeSuper","_Error2","_this2","_Error3","_this3","AssertionError","_Error4","_this4","actual","expected","AssertionValueError","_AssertionError","_this5","AssertionUndefinedError","_AssertionError2","propertyPath","_this6","AssertionDefinedError","_AssertionError3","actualValue","_this7","AssertionWrongInstanceError","_AssertionError4","actualObject","expectedClassType","_this8","constructor","AssertionNoErrorThrownError","_AssertionError5","_this9","AssertionWrongErrorInstanceError","_AssertionError6","actualError","_this0","AssertionArrayLengthError","_AssertionError7","actualLength","expectedLength","_this1","AssertionArrayLengthMinimalError","_AssertionError8","_this10","AssertionArrayIncludingError","_AssertionError9","array","expectedValue","_this11","AssertionArrayExcludingError","_AssertionError0","_this12","AssertionJSONObjectError","_AssertionError1","mismatchesPaths","_this13","mismatches","map","path","join","ConfigTester","_GVAbstractTester","url","HISTORICAL_FLOOD_URL_MAP_SERVER","testEsriDynamic","metadataAccessPath","listOfLayerEntryConfig","layerEntryProps","layerName","HISTORICAL_FLOOD_LAYER_NAME","EsriDynamicLayerEntryConfig","CESI_MAP_SERVER","CESI_GROUP_0_LAYER_NAME","GroupLayerEntryConfig","testName","expectedConfig","expectedTypeFirstLayerEntry","gvLayerId","gvLayerName","expectedConfigFull","geoviewLayerId","geoviewLayerName","geoviewLayerType","EsriDynamic","initGeoviewLayerConfig","assertJsonObject","layerEntry","assertIsInstance","urlBad","GVAbstractTester","BAD_URL","testError","LayerServiceMetadataUnableToFetchError","_ref","FEATURE_SERVER_TORONTO_NEIGHBOURHOODS_URL","testEsriFeature","layerId","FEATURE_SERVER_TORONTO_NEIGHBOURHOODS_LAYER_NAME","HISTORICAL_FLOOD_URL_FEATURE_SERVER","expectedUrl","FOREST_INDUSTRY_FEATURE_SERVER","FOREST_INDUSTRY_MAP_SERVER","FOREST_INDUSTRY_LAYER_NAME","EsriFeature","EsriFeatureLayerEntryConfig","_ref2","IMAGE_SERVER_ELEVATION_URL","testEsriImage","IMAGE_SERVER_ELEVATION_LAYER_ID","EsriImage","EsriImageLayerEntryConfig","_ref3","_callee3","_context3","OWS_MUNDIALIS","WMS","assertIsArrayLengthEqual","OgcWmsLayerEntryConfig","assertIsEqual","DATACUBE_MSI","layerEntryFirst","DATACUBE_MSI_LAYER_NAME_MSI","layerEntrySecond","DATACUBE_MSI_LAYER_NAME_MSI_OR_MORE","LayerNoCapabilitiesError","_ref4","_callee4","_context4","GEOMET_URL","WFS","foundLayerEntry","find","GEOMET_URL_CURRENT_COND_LAYER_ID","assertIsDefined","WfsLayerEntryConfig","_ref5","_callee5","_context5","FAKE_URL_ALWAYS_RETURNING_RESPONSE_INSTEAD_OF_NETWORK_ERROR","_ref6","_callee6","_context6","GEOJSON_METADATA_META","GeoJSON","GEOJSON_METADATA_META_FILE","GeoJSONLayerEntryConfig","_ref7","_callee7","_context7","_ref8","_callee8","_context8","CSV_STATION_LIST","CSV","CSV_STATION_LIST_FILE","CsvLayerEntryConfig","_ref9","_callee9","_context9","PYGEOAPI_B6RYUVAKK5","OgcFeature","PYGEOAPI_B6RYUVAKK5_LAKES","OgcFeatureLayerEntryConfig","_ref0","_callee0","_context0","_x0","WKB_SOUTH_AFRICA","WKB","WkbLayerEntryConfig","_ref1","_callee1","_context1","_x1","KML_TORNADO","KML","KML_TORNADO_FILE","KmlLayerEntryConfig","_ref10","_callee10","_context10","_x10","uuid","AIRBORNE_RADIOACTIVITY_UUID","config","AIRBORNE_RADIOACTIVITY_LAYER_GROUP_NAME","geocharts","_defineProperty","AIRBORNE_RADIOACTIVITY_UUID_WITH_SUFFIX","layers","chart","GeoCore","createLayerConfigFromUUID","_configTester","GVTestSuiteConfig","pEsriDynamicHistoFlood","testEsriDynamicWithHistoricalFloodEvents","pEsriDynamicCESI","testEsriDynamicWithCESI","pEsriDynamicBadUrl","testEsriDynamicBadUrl","pEsriFeatureToronto","testEsriFeatureWithTorontoNeighbourhoods","pEsriFeatureHisto","testEsriFeatureWithHistoricalFloodEvents","pEsriFeatureForest","testEsriFeatureWithForestIndustry","pEsriFeatureBadUrl","testEsriFeatureBadUrl","pEsriImage","testEsriImageWithElevation","pEsriImageBadUrl","testEsriImageBadUrl","pWMSMundialis","testWMSLayerWithOWSMundialis","pWMSDatacubeMSI","testWMSLayerWithDatacubeMSI","pWMSBadUrl","testWMSBadUrl","pWFSCurrentConditions","testWFSLayerWithGeometCurrentConditions","pWFSBadUrl","testWFSBadUrl","pWFSOkayUrlNoCap","testWFSOkayUrlNoCap","pOGcFeature","testOGCFeatureWithPygeoapi","pOgcFeatureBadUrl","testOGCFeatureBadUrl","pGeoJson","testGeojsonWithMetadataMeta","pGeoJsonBadUrlSkip","testGeoJSONBadUrlExpectSkip","pGeoJsonBadUrlFail","testGeoJSONBadUrlExpectError","pCSV","testCSVWithStationList","pCSVBadUrlSkip","testCSVBadUrlExpectSkip","pWKB","testWKBWithSouthAfrica","pWKBBadUrlFail","testWKBBadUrlExpectFail","pKMLTornado","testKMLWithTornado","pKMLSkip","testKMLBadUrlExpectSkip","pGeocoreAirborne","testStandaloneGeocoreWithAirborne","LayerTester","generateId","layerUrl","layerPath","HISTORICAL_FLOOD_URL_LAYER_ID","gvConfig","createGeoviewLayerConfig","helperStepAddLayerOnMap","getMapViewer","helperStepCheckLayerAtLayerPath","helperStepAssertLayerExists","helperFinalizeStepRemoveLayerAndAssert","helperFinalizeStepRemoveLayerConfigAndAssert","ESRI_DYNAMIC_LABOUR_FORCE_UUID","layerPathGroup","ESRI_DYNAMIC_LABOUR_FORCE_GROUP","layerPathPetroleum","ESRI_DYNAMIC_LABOUR_FORCE_PETROLEUM","layerPathMinerals","ESRI_DYNAMIC_LABOUR_FORCE_MINERALS","layerPathForestry","ESRI_DYNAMIC_LABOUR_FORCE_FORESTRY","layerPathFisheries","ESRI_DYNAMIC_LABOUR_FORCE_FISHERIES","layerPathAgriculture","ESRI_DYNAMIC_LABOUR_FORCE_AGRICULTURE","layerPathCanecumene","ESRI_DYNAMIC_LABOUR_FORCE_CANECUMENE","helperStepAddLayerOnMapFromUUID","FOREST_INDUSTRY_LAYER_ID","createGeoviewLayerConfigSimple","IMAGE_SERVER_USA_URL","layerPathCities","IMAGE_SERVER_USA_LAYER_ID_CITIES","layerPathRoads","IMAGE_SERVER_USA_LAYER_ID_ROADS","OWS_MUNDIALIS_LAYER_ID","hasStyle","DATACUBE_RING_FIRE","DATACUBE_RING_FIRE_LAYER_ID_HALIFAX","_ref11","_callee11","_context11","_x11","_ref12","_callee12","_context12","_x12","_ref13","_callee13","_context13","_x13","_this14","GEOJSON_POLYGONS","_ref14","_callee14","_context14","_x14","_this15","LayerStatusErrorError","_ref15","_callee15","_context15","_x15","_this16","_ref16","_callee16","_context16","_x16","_this17","_ref17","_callee17","_context17","_x17","_this18","_ref18","_callee18","_context18","_x18","_this19","_ref19","_callee19","_context19","_x19","_this20","_ref20","_callee20","_context20","_x20","_this21","_ref21","_callee21","_context21","_x21","_this22","_ref22","_callee22","_context22","_x22","_this23","_ref23","_callee23","_context23","_x23","_helperStepAddLayerOnMap","_callee24","_context24","layer","addGeoviewLayer","promiseLayer","throwAggregatedLayerLoadErrors","_x24","_x25","_x26","_helperStepAddLayerOnMapFromUUID","_callee25","_context25","addGeoviewLayerByGeoCoreUUID","_x27","_x28","_x29","_helperStepCheckLayerAtLayerPath","_callee26","waitStyle","_args26","_context26","getGeoviewLayer","waitLoadedOnce","waitLegendFetched","waitStyleApplied","_x30","_x31","_x32","checkStyle","legendLayer","LegendEventProcessor","getLegendLayerInfo","helperStepAssertStyleApplied","assertIsArrayLengthMinimal","icons","firstIcon","hasStyleIcon","iconImage","assertArrayIncludes","getGeoviewLayerPaths","removeLayerUsingPath","legendLayers","getLegendLayers","assertArrayExcludes","getLayerEntryConfigIfExists","assertIsUndefined","_AbstractTester","_title","_type","_steps","_status","_error","_onStatusChangedHandlers","_onStepChangedHandlers","_Test_brand","title","type","status","_emitStatusChanged","steps","getSteps","_step","html","currentMajorHtml","nestedSteps","_iterator","_createForOfIteratorHelper","s","n","done","step","level","color","err","e","f","TestStep","expectedType","expectedMinimumLength","_array$length","_array$length2","includes","expectedObject","_jsonObjectIsAtLeast","ok","basePath","currentPath","_typeof","JSON","stringify","Array","isArray","i","_step2","expectedItem","foundMatch","failedMismatches","_iterator2","actualItem","_toConsumableArray","_i","_Object$keys","keys","childResult","_Test","_geochartTester","GVTestSuiteGeochart","GeochartTester","_this$getMapViewer$ma","mapFeaturesConfig","footerBar","tabs","core","_onLaunchTestSuite","pGeochartPolygons","pGeochartAirborne","testGeochartOpenForLayerMapClick","MANITOBA_CENTER_LONLAT","testAddGeocoreLayerUUIDForGeochartAirborne","lonlat","helperStepLayerWithGeochart","UIEventProcessor","getActiveFooterBarTab","getMapId","GeochartEventProcessor","getSingleGeochartState","testAddGeocoreLayerUUIDForGeochart","AIRBORNE_RADIOACTIVITY_GROUP","QUEBEC_LONLAT","propertyValue","propertyDisplay","query","queryOptions","whereClauses","field","prefix","valueFrom","suffix","orderByField","layerPathAdd","layerPathRemove","expectedGeochartChartsConfig","geochartsConfig","_helperStepLayerWithGeochart","featureInfoLayerSet","queryLayers","setActiveFooterBarTab","delay","setSelectedGeochartLayerPath","_suitesCompleted","_onSuiteTestersTestStartedHandlers","_onSuiteTestersTestUpdatedHandlers","_onSuiteTestersTestSuccessHandlers","_onSuiteTestersTestFailureHandlers","_TestSuitePlugin_brand","TestSuitePlugin","_AbstractPlugin","_len","args","_key","_classPrivateMethodInitSpec","getConfig","suites","PluginConfigNotFoundError","pluginId","suite","addTestSuite","window","cgpv","GVTestSuiteLayer","TestSuiteInitializationError","testSuite","testSuites","onTestStarted","onTestUpdated","_launchTestSuites","_this$suitesCompleted","resetTestSuites","launchTestSuite","finish","resetTestSuite","getDescriptionAsHtml","getSuitesCompleted","getSuitesTotal","getSuitesDone","AbstractPlugin","React","reactUtilities","react","geoviewPlugins","_MapTester_brand","currentProjection","_getMapConfigFromStore","viewSettings","projection","MapEventProcessor","getMapState","zoomEnd","zoomDuration","currentZoom","zoom","mapConfig","getGeoViewMapConfig","_layerTester","pLayerEsriDynamicHistoFloods","testAddEsriDynamicHistoFloodEvents","pLayerEsriDynamicWithRasterLayersViaGeocore","testAddEsriDynamicWithRasterLayersViaGeocore","pLayerEsriDynamicBadUrl","testAddEsriDynamicBadUrl","pLayerEsriFeatureForestIndustry","testAddEsriFeatureForestIndustry","pLayerEsriFeatureBadUrl","testAddEsriFeatureBadUrl","pLayerEsriImageElevation","testAddEsriImageWithElevation","pLayerEsriImageBadUrl","testAddEsriImageBadUrl","pLayerWMSOWSMundialis","testAddWMSLayerWithOWSMundialis","pLayerWMSDatacubeOWSMSI","testAddWMSLayerWithDatacubeMSI","pLayerWMSDatacubeRingFireHalifax","testAddWMSLayerWithDatacubeRingOfFire","pLayerWMSBadUrl","testAddWMSBadUrl","pLayerWFSWithGeometCurrentConditions","testAddWFSLayerWithWithGeometCurrentConditions","pLayerWFSBadUrl","testAddWFSBadUrl","pLayerWFSOkayUrlNoCap","testAddWFSOkayUrlNoCap","pLayerGeoJSONWithPolygons","testAddGeoJSONWithMetadataPolygons","pLayerGeoJSonBadUrl","testAddGeoJSONBadUrl","pLayerCSVStationList","testAddCSVWithStationList","pLayerCSVBadUrl","testAddCSVWithBadUrl","pLayerOGCFeatureWithPygeoapi","testAddOGCFeatureWithPygeoapi","pLayerOGCFeatureBadUrl","testAddOGCFeatureWithBadUrl","pLayerWKBWithSouthAfrica","testAddWKBWithSouthAfrica","pLayerWKBBadUrl","testAddWKBWithBadUrl","pLayerKMLWithTornado","testAddKMLWithTornado","pLayerKMLBadUrl","testAddKMLWithBadUrl"],"sourceRoot":""}